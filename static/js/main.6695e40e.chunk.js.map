{"version":3,"sources":["PathFindingVisualizer/mazeAlgorithms/recursizeDivision.js","PathFindingVisualizer/mazeAlgorithms/verticalMaze.js","PathFindingVisualizer/mazeAlgorithms/horizontalMaze.js","PathFindingVisualizer/node/node.jsx","PathFindingVisualizer/algorithm/dijkstra.js","PathFindingVisualizer/algorithm/astar.js","PathFindingVisualizer/algorithm/breadthFirstSearch.js","PathFindingVisualizer/algorithm/depthFirstSearch.js","PathFindingVisualizer/algorithm/greedyBestFirstSearch.js","PathFindingVisualizer/algorithm/bidirectionalGreedySearch.js","PathFindingVisualizer/PathFindingVisualizer.jsx","PathFindingVisualizer/mazeAlgorithms/randomMaze.js","Screens/PathFindingVisualizerScreen.js","SortingVisualizer/SortingAnimations/bubbleSortAnimation.js","SortingVisualizer/SortingAlgorithms/bubbleSort.js","SortingVisualizer/SortingAlgorithms/quickSort.js","SortingVisualizer/SortingAnimations/quickSortAnimation.js","SortingVisualizer/SortingAnimations/selectionSortAnimation.js","SortingVisualizer/SortingAlgorithms/selectionSort.js","SortingVisualizer/SortingAnimations/insertionSortAnimation.js","SortingVisualizer/SortingAlgorithms/insertionSort.js","SortingVisualizer/SortingAlgorithms/mergeSort.js","SortingVisualizer/SortingAnimations/mergeSortAnimation.js","SortingVisualizer/components/bubbleSortComponent.jsx","SortingVisualizer/components/mergeSortComponent.jsx","SortingVisualizer/SortingVisualizer.js","navbar/navbar.jsx","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","props","cellHeight","row","col","isStart","isFinish","isWall","isVisited","isShortest","width","height","numRows","numColumns","onDragStart","onDragOver","onDrop","extraClass","isPlace","cellWidth","Math","floor","id","draggable","event","className","style","e","dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","Infinity","updateUnvisitedNeighbours","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","getNeighbours","neighbourNotInUnvisitedNodes","manhattenDistance","abs","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","colStart","rowFinish","colFinish","nodeA","nodeB","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startFinishNode","randomNums","x","y","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","getRandomNums","getStartFinishNode","getNewGridWithMaze","newGrid","newNode","getVisitedNodesInOrder","visitedNodesInOrderStart","visitedNodesInOrderFinish","n","undefined","randomNums1","randomNums2","PathFindingVisualizer","useState","setGrid","setWidth","setHeight","speed","setSpeed","visualizingAlgorithm","setVisualizingAlgorithm","generatingMaze","setGeneratingMaze","mazeSpeed","setMazeSpeed","currAlgo","setCurrAlgo","maze","setMaze","dragStartData","setDragStartData","dragEndData","setDragEndData","sNode","setSNode","fNode","setFNode","isTarget","setIsTarget","useEffect","addEventListener","updateDimensions","getInitialGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","updateNodesForRender","document","getElementById","animateAlgorithm","visualizeAStar","totalDistance","unshift","astar","currentNode","getNodesInShortestPathOrderAstar","visualizeBFS","breadthFirstSearch","getNodesInShortestPathOrderBFS","visualizeDFS","depthFirstSearch","getNodesInShortestPathOrderDFS","visualizeGreedyBFS","greedyBFS","getNodesInShortestPathOrderGreedyBFS","visualizeBidirectionalGreedySearch","unvisitedNodesStart","unvisitedNodesFinish","bidirectionalGreedySearch","isShortedPath","animateBidirectionalAlgorithm","getNodesInShortestPathOrderBidirectionalGreedySearch","clearGrid","animateMaze","generateRandomMaze","randomMaze","currentRow","createNode","onChange","target","value","handleAlgoChange","onClick","getNodesInShortestPathOrderDijkstra","backgroundColor","color","borderColor","padding","position","left","handleMazeChange","type","handleSpeed","map","rowId","nodeId","preventDefault","handleDragOver","handleDragStart","handleDrop","PathFindingVisualizerScreen","PRIMARY_COLOR","bubbleSortAnimation","ANIMATION_SPEED_MS","animations","arr","k","j","bubbleSort","arrayBars","getElementsByClassName","child","barIdx","barOneIdx","barTwoIdx","barOneStyle","barTwoStyle","quickSort","quickSortHelper","start","end","pIndex","pivot","swap","partition","FINAL_COLOR","quickSortAnimation","isColorChange","element","console","log","minIdx","selectionSort","colorOne","colorTwo","barThreeStyle","insertionSortAnimation","key","insertionSort","keyHeight","barStyle","mergeSort","auxillaryArray","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","doMerge","mergeSortAnimation","newHeight","allBars","querySelectorAll","BubbleSortComponent","textAlign","fontWeight","marginTop","marginBottom","MergeSortComponent","useStyles","makeStyles","root","bottom","label","fontSize","top","SortingVisualizer","classes","setArray","setValue","setANIMATION_SPEED_MS","currentSort","setCurrentSort","getWindowDimensions","_width","_height","randomIntFromInterval","_resetArray","newWidth","resetArray","NO_OF_ARRAY_BAR","min","_bubbleSort","paddingTop","display","Typography","Slider","aria-labelledby","selected","selectionSortAnimation","_value","index","paddingLeft","NavBar","logo","class","to","App","exact","path","component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"oQAAIA,ECAAA,ECAAA,E,mGCmFWC,EAhFF,SAACC,GAAW,IA4DjBC,EA1DJC,EAcEF,EAdFE,IACAC,EAaEH,EAbFG,IACAC,EAYEJ,EAZFI,QACAC,EAWEL,EAXFK,SACAC,EAUEN,EAVFM,OACAC,EASEP,EATFO,UACAC,EAQER,EARFQ,WACAC,EAOET,EAPFS,MACAC,EAMEV,EANFU,OACAC,EAKEX,EALFW,QACAC,EAIEZ,EAJFY,WACAC,EAGEb,EAHFa,YACAC,EAEEd,EAFFc,WACAC,EACEf,EADFe,OAGIC,EAAaZ,EACf,kBACAC,EACA,mBACAC,EACA,YACAE,EACA,0BACAD,EACA,oBACA,OAIIU,EAAUb,GAAWC,EA2BvBa,EAAYC,KAAKC,OAAOX,EAAQ,IAAMG,GAY1C,OAVIH,EAAQ,MAEDA,EAAQ,IADjBR,EAAakB,KAAKC,OAAOV,EAAS,IAAMC,GAG/BF,EAAQ,IACjBR,EAAakB,KAAKC,OAAOV,EAAS,IAAMC,GAC/BF,EAAQ,IACjBR,EAAakB,KAAKC,OAAOV,EAAS,IAAMC,IAItC,mCAtCAM,EAEA,qBACEI,GAAE,eAAUnB,EAAV,YAAiBC,GACnBmB,WAAS,EACTT,YAAa,SAACU,GAAD,OAASV,EAAYU,IAClCC,UAAS,UAAKR,GACdS,MAAO,CAAE,UAAU,GAAV,OAAcP,EAAd,MAA6B,WAAW,GAAX,OAAejB,EAAf,SAKxC,qBACEoB,GAAE,eAAUnB,EAAV,YAAiBC,GACnBW,WAAY,SAACY,GAAD,OAAKZ,EAAWY,IAC5BX,OAAQ,kBAAIA,KACZS,UAAS,eAAUR,GACnBS,MAAO,CAAE,UAAU,GAAV,OAAcP,EAAd,MAA6B,WAAW,GAAX,OAAejB,EAAf,Y,MCtDzC,SAAS0B,EAASC,EAAMC,EAAWC,GACtC,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAETD,EAAUE,SAAW,EAGrB,IAFA,IAAIC,EAcN,SAAkBJ,GAChB,IADsB,EAClBK,EAAQ,GADU,cAENL,GAFM,IAEtB,2BAAsB,CAAC,IAAD,EAAb1B,EAAa,sBACHA,GADG,IACpB,2BAAsB,CAAC,IAAdgC,EAAa,QACpBD,EAAME,KAAKD,IAFO,gCAFA,8BAOtB,OAAOD,EArBcG,CAASR,GAC1BS,EAAsB,GACO,IAA1BL,EAAeM,QAAc,CAClCN,EAAeO,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAET,SAAWU,EAAEV,YAC7C,IAAIW,EAAcV,EAAeW,QACjC,IAAID,EAAYpC,OAAhB,CACA,GAAIoC,EAAYX,WAAaa,IAAU,OAAOP,EAC9C,GAAIK,IAAgBZ,EAAY,OAAOO,EACvCK,EAAYnC,WAAY,EACxB8B,EAAoBF,KAAKO,GACzBG,EAA0BH,EAAad,KAc3C,SAASiB,EAA0BX,EAAMN,GACvC,IAD6C,EACzCkB,EAON,SAAgCZ,EAAMN,GACpC,IAAImB,EAAa,GACX7C,EAAagC,EAAbhC,IAAKC,EAAQ+B,EAAR/B,IACC,IAARD,GAAW6C,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACzCA,IAAQyB,EAAK,GAAGU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC5DD,IAAQ0B,EAAKU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IAC/C,IAARA,GAAW4C,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC/C,OAAO4C,EACJC,QAAO,SAACC,GAAD,OAAgBA,EAAU3C,UACjC0C,QAAO,SAACC,GAAD,OAAgBA,EAAU1C,aAhBV2C,CAAuBhB,EAAMN,GADV,cAEdkB,GAFc,IAE7C,2BAAoD,CAAC,IAA5CK,EAA2C,QAClDA,EAAmBpB,SAAWG,EAAKH,SAAW,EAC9CoB,EAAmBC,aAAelB,GAJS,+BCS/C,SAASmB,EAAcnB,EAAMN,GAC3B,IAAImB,EAAa,GACX7C,EAAagC,EAAbhC,IAAKC,EAAQ+B,EAAR/B,IAKX,OAJIA,IAAQyB,EAAK,GAAGU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC5DD,IAAQ0B,EAAKU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IAC/C,IAARA,GAAW4C,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IACnC,IAARD,GAAW6C,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACtC4C,EAAWC,QAChB,SAACC,GAAD,OAAgBA,EAAU3C,SAAW2C,EAAU1C,aAInD,SAAS+C,EAA6BL,EAAWjB,GAAiB,IAAD,gBAC9CA,GAD8C,IAC/D,2BAAiC,CAAC,IAAzBE,EAAwB,QAC/B,GAAIA,EAAKhC,MAAQ+C,EAAU/C,KAAOgC,EAAK/B,MAAQ8C,EAAU9C,IACvD,OAAO,GAHoD,8BAM/D,OAAO,EAGT,SAASoD,EAAkBrB,EAAMJ,GAG/B,OAFQX,KAAKqC,IAAItB,EAAKhC,IAAM4B,EAAW5B,KAC/BiB,KAAKqC,IAAItB,EAAK/B,IAAM2B,EAAW3B,KCrCzC,SAAS+C,EAAuBhB,EAAMN,GACpC,IAAImB,EAAa,GACX7C,EAAagC,EAAbhC,IAAKC,EAAQ+B,EAAR/B,IAKX,OAJY,IAARD,GAAW6C,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACzCA,IAAQyB,EAAK,GAAGU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC5DD,IAAQ0B,EAAKU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IAC/C,IAARA,GAAW4C,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IACxC4C,EAAWC,QAAO,SAACC,GAAD,OAAgBA,EAAU1C,aAGrD,SAAS+C,EAA6BL,EAAWjB,GAAiB,IAAD,gBAC9CA,GAD8C,IAC/D,2BAAiC,CAAC,IAAzBE,EAAwB,QAC/B,GAAIA,EAAKhC,MAAQ+C,EAAU/C,KAAOgC,EAAK/B,MAAQ8C,EAAU9C,IACvD,OAAO,GAHoD,8BAM/D,OAAO,EClBT,SAAS+C,EAAuBhB,EAAMN,GACpC,IAAImB,EAAa,GACX7C,EAAagC,EAAbhC,IAAKC,EAAQ+B,EAAR/B,IAKX,OAJY,IAARA,GAAW4C,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IACnC,IAARD,GAAW6C,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACzCA,IAAQyB,EAAK,GAAGU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC5DD,IAAQ0B,EAAKU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACpD4C,EAAWC,QAAO,SAACC,GAAD,OAAgBA,EAAU1C,aCOrD,SAAS8C,EAAcnB,EAAMN,GAC3B,IAAImB,EAAa,GACX7C,EAAagC,EAAbhC,IAAKC,EAAQ+B,EAAR/B,IAKX,OAJY,IAARD,GAAW6C,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACzCA,IAAQyB,EAAK,GAAGU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC5DD,IAAQ0B,EAAKU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IAC/C,IAARA,GAAW4C,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IACxC4C,EAAWC,QAChB,SAACC,GAAD,OAAgBA,EAAU3C,SAAW2C,EAAU1C,aAInD,SAASgD,EAAkBrB,EAAMJ,GAG/B,OAFQX,KAAKqC,IAAItB,EAAKhC,IAAM4B,EAAW5B,KAC/BiB,KAAKqC,IAAItB,EAAK/B,IAAM2B,EAAW3B,KAIzC,SAASmD,EAA6BL,EAAWjB,GAAiB,IAAD,gBAC9CA,GAD8C,IAC/D,2BAAiC,CAAC,IAAzBE,EAAwB,QAC/B,GAAIA,EAAKhC,MAAQ+C,EAAU/C,KAAOgC,EAAK/B,MAAQ8C,EAAU9C,IACvD,OAAO,GAHoD,8BAM/D,OAAO,ECiBT,SAASsD,EAAYC,EAAkBC,GACrC,IAAIC,EAAWF,EAAiBxD,IAC5B2D,EAAWH,EAAiBvD,IAC5B2D,EAAYH,EAAkBzD,IAC9B6D,EAAYJ,EAAkBxD,IAClC,OAAI2D,IAAcF,EAAW,GAAKG,IAAcF,IAC5CC,IAAcF,GAAYG,IAAcF,EAAW,IACnDC,IAAcF,EAAW,GAAKG,IAAcF,GAC5CC,IAAcF,GAAYG,IAAcF,EAAW,IAIzD,SAASR,EAAcnB,EAAMN,GAC3B,IAAImB,EAAa,GACX7C,EAAagC,EAAbhC,IAAKC,EAAQ+B,EAAR/B,IAKX,OAJY,IAARD,GAAW6C,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IACzCA,IAAQyB,EAAK,GAAGU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IAC5DD,IAAQ0B,EAAKU,OAAS,GAAGS,EAAWZ,KAAKP,EAAK1B,EAAM,GAAGC,IAC/C,IAARA,GAAW4C,EAAWZ,KAAKP,EAAK1B,GAAKC,EAAM,IACxC4C,EAAWC,QAChB,SAACC,GAAD,OAAgBA,EAAU3C,SAAW2C,EAAU1C,aAInD,SAASgD,EAAkBS,EAAOC,GAGhC,OAFQ9C,KAAKqC,IAAIQ,EAAM9D,IAAM+D,EAAM/D,KAC3BiB,KAAKqC,IAAIQ,EAAM7D,IAAM8D,EAAM9D,KAIrC,SAASmD,EAA6BL,EAAWjB,GAAiB,IAAD,gBAC9CA,GAD8C,IAC/D,2BAAiC,CAAC,IAAzBE,EAAwB,QAC/B,GAAIA,EAAKhC,MAAQ+C,EAAU/C,KAAOgC,EAAK/B,MAAQ8C,EAAU9C,IACvD,OAAO,GAHoD,8BAM/D,OAAO,EThHJ,SAAS+D,EAAsBtC,EAAMC,EAAWC,GACrD,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIqC,EAAWC,EAAMxC,EAAK,GAAGU,QACzB+B,EAAaD,EAAMxC,EAAKU,QAG5B,OAFAxC,EAAQ,GACRwE,EAAkBH,EAAUE,EAAYzC,EAAMC,EAAWC,GAClDhC,EAGT,SAASsE,EAAMG,GAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAOrC,KAAKsC,GAEd,OAAOD,EAMT,SAASF,EAAkBH,EAAUE,EAAYzC,EAAMC,EAAWC,GAIhE,IAAI4C,EACAC,EAJAR,EAAS7B,OAAS,GAAK+B,EAAW/B,OAAS,IAK3C6B,EAAS7B,OAAS+B,EAAW/B,SAC/BoC,EAAM,EACNC,EAAMC,EAAwBT,IAE5BA,EAAS7B,QAAU+B,EAAW/B,SAChCoC,EAAM,EACNC,EAAMC,EAAwBP,IAGpB,IAARK,GACFG,EAAQH,EAAKC,EAAKR,EAAUE,EAAYxC,EAAWC,GACnDwC,EACEH,EAASW,MAAM,EAAGX,EAASY,QAAQJ,IACnCN,EACAzC,EACAC,EACAC,GAEFwC,EACEH,EAASW,MAAMX,EAASY,QAAQJ,GAAO,GACvCN,EACAzC,EACAC,EACAC,KAGF+C,EAAQH,EAAKC,EAAKR,EAAUE,EAAYxC,EAAWC,GACnDwC,EACEH,EACAE,EAAWS,MAAM,EAAGT,EAAWU,QAAQJ,IACvC/C,EACAC,EACAC,GAEFwC,EACEH,EACAE,EAAWS,MAAMT,EAAWU,QAAQJ,GAAO,GAC3C/C,EACAC,EACAC,KAKN,SAAS8C,EAAwBI,GAC/B,IAAIC,EAAMD,EAAM1C,OAAS,EACrB4C,EACF/D,KAAKC,MAAMD,KAAKgE,UAAYF,EAAM,IAClC9D,KAAKC,MAAMD,KAAKgE,UAAYF,EAAM,IAQpC,OAPIC,EAAY,IAAM,IAChBA,IAAcD,EAChBC,GAAa,EAEbA,GAAa,GAGVF,EAAME,GAMf,SAASL,EAAQH,EAAKC,EAAKR,EAAUE,EAAYxC,EAAWC,GAC1D,IAAIsD,GAAgB,EAChBC,EAAY,GAChB,GAAY,IAARX,EAAW,CACb,GAA0B,IAAtBL,EAAW/B,OAAc,OADhB,oBAEI+B,GAFJ,IAEb,2BAA6B,CAAC,IAArBiB,EAAoB,QAExBA,IAASzD,EAAU3B,KAAOyE,IAAQ9C,EAAU1B,KAC5CmF,IAASxD,EAAW5B,KAAOyE,IAAQ7C,EAAW3B,IAE/CiF,GAAgB,EAGlBC,EAAUlD,KAAK,CAACmD,EAAMX,KAVX,mCAYR,CACL,GAAwB,IAApBR,EAAS7B,OAAc,OADtB,oBAEY6B,GAFZ,IAEL,2BAA2B,CAAC,IAAnBmB,EAAkB,QAEtBX,IAAQ9C,EAAU3B,KAAOoF,IAASzD,EAAU1B,KAC5CwE,IAAQ7C,EAAW5B,KAAOoF,IAASxD,EAAW3B,IAE/CiF,GAAgB,EAGlBC,EAAUlD,KAAK,CAACwC,EAAKW,KAVlB,+BAaFF,GACHC,EAAUE,OAOd,SAA8BN,GAC5B,IAAIC,EACF/D,KAAKC,MAAMD,KAAKgE,UAAYF,EAAM,IAClC9D,KAAKC,MAAMD,KAAKgE,UAAYF,EAAM,IAChCC,EAAY,IAAM,IAChBA,IAAcD,EAChBC,GAAa,EAEbA,GAAa,GAGjB,OAAOA,EAlBYM,CAAqBH,EAAU/C,QAAS,GAE3D,cAAiB+C,EAAjB,eAA4B,CAAvB,IAAII,EAAI,KACX3F,EAAMqC,KAAKsD,IC1HR,SAASC,EAAa9D,EAAMC,EAAWC,GAC5C,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIqC,EAAWC,EAAMxC,EAAK,GAAGU,QACzB+B,EAAaD,EAAMxC,EAAKU,QAG5B,OAFAxC,EAAQ,GAaV,SAA0BqE,EAAUE,EAAYxC,EAAWC,GACzD,GAAIqC,EAAS7B,OAAS,EACpB,OAGF,IALqE,EAKjEqD,EAASxE,KAAKC,MAAsB,EAAhBD,KAAKgE,UALwC,cAMrDhB,GANqD,IAMrE,2BAA0B,CAAC,IAAlBQ,EAAiB,QACT,IAAXgB,GAAgBhB,EAAM,IAAM,GAC9BE,EAAQF,EAAKN,EAAYxC,EAAWC,GAEvB,IAAX6D,GAAgBhB,EAAM,IAAM,GAC9BE,EAAQF,EAAKN,EAAYxC,EAAWC,IAX6B,+BAZrE8D,CAAiBzB,EAAUE,EAAYxC,EAAWC,GAC3ChC,EAGT,SAASsE,EAAMG,GAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAOrC,KAAKsC,GAEd,OAAOD,EAmBT,SAASK,EAAQF,EAAKN,EAAYxC,EAAWC,GAC3C,IADuD,EACnDsD,GAAgB,EAChBC,EAAY,GAFuC,cAGtChB,GAHsC,IAGvD,2BAA6B,CAAC,IAArBiB,EAAoB,QAExBA,IAASzD,EAAU3B,KAAOyE,IAAQ9C,EAAU1B,KAC5CmF,IAASxD,EAAW5B,KAAOyE,IAAQ7C,EAAW3B,IAE/CiF,GAAgB,EAGlBC,EAAUlD,KAAK,CAACmD,EAAMX,KAX+B,8BAalDS,GACHC,EAAUE,OAAOpE,KAAKC,MAAMD,KAAKgE,SAAWE,EAAU/C,QAAS,GAEjE,cAAiB+C,EAAjB,eAA4B,CAAvB,IAAII,EAAI,KACX3F,EAAMqC,KAAKsD,ICpDR,SAASI,EAAejE,EAAMC,EAAWC,GAC9C,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIqC,EAAWC,EAAMxC,EAAK,GAAGU,QACzB+B,EAAaD,EAAMxC,EAAKU,QAG5B,OAFAxC,EAAQ,GAaV,SAA4BqE,EAAUE,EAAYxC,EAAWC,GAC3D,GAAIuC,EAAW/B,OAAS,EACtB,OAGF,IALuE,EAKnEqD,EAASxE,KAAKC,MAAsB,EAAhBD,KAAKgE,UAL0C,cAMvDd,GANuD,IAMvE,2BAA4B,CAAC,IAApBM,EAAmB,QACX,IAAXgB,GAAgBhB,EAAM,IAAM,GAC9BE,EAAQF,EAAKR,EAAUtC,EAAWC,GAErB,IAAX6D,GAAgBhB,EAAM,IAAM,GAC9BE,EAAQF,EAAKR,EAAUtC,EAAWC,IAXiC,+BAZvEgE,CAAmB3B,EAAUE,EAAYxC,EAAWC,GAC7ChC,EAGT,SAASsE,EAAMG,GAEb,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACvBD,EAAOrC,KAAKsC,GAEd,OAAOD,EAmBT,SAASK,EAAQF,EAAKR,EAAUtC,EAAWC,GACzC,IADqD,EACjDsD,GAAgB,EAChBC,EAAY,GAFqC,cAGpClB,GAHoC,IAGrD,2BAA2B,CAAC,IAAnBmB,EAAkB,QAEtBX,IAAQ9C,EAAU3B,KAAOoF,IAASzD,EAAU1B,KAC5CwE,IAAQ7C,EAAW5B,KAAOoF,IAASxD,EAAW3B,IAE/CiF,GAAgB,EAGlBC,EAAUlD,KAAK,CAACwC,EAAKW,KAX8B,8BAahDF,GACHC,EAAUE,OAAOpE,KAAKC,MAAMD,KAAKgE,SAAWE,EAAU/C,QAAS,GAEjE,cAAiB+C,EAAjB,eAA4B,CAAvB,IAAII,EAAI,KACX3F,EAAMqC,KAAKsD,IQtBf,IAAMM,EAijBN,SAAuBtF,EAAOC,GAC5B,IAAIE,EACAH,EAAQ,KACVG,EAAaO,KAAKC,MAAMX,EAAQ,IACvBA,EAAQ,KACjBG,EAAaO,KAAKC,MAAMX,EAAQ,MACvBA,EAAQ,IACjBG,EAAaO,KAAKC,MAAMX,EAAQ,IACvBA,EAAQ,IACjBG,EAAaO,KAAKC,MAAMX,EAAQ,MACvBA,EAAQ,IACjBG,EAAaO,KAAKC,MAAMX,EAAQ,IACvBA,EAAQ,IACjBG,EAAaO,KAAKC,MAAMX,EAAQ,MACvBA,EAAQ,IACjBG,EAAaO,KAAKC,MAAMX,EAAQ,IAAM,GAExC,IAAIS,EAAYC,KAAKC,MAAMX,EAAQG,GAEnC,MAAO,CADOO,KAAKC,MAAMV,EAASQ,GAAa,EAC9BN,GApkBAoF,CAAcC,OAAOC,WAAW,IAAKD,OAAOE,YAAY,KACrEC,EAAiBL,EAAW,GAC5BM,EAAoBN,EAAW,GAE/BO,EAsnBN,SAA4B3F,EAASC,GACnC,IAAI2F,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAlG,EAAUC,GACZ2F,EAAaO,EAAcnG,GAC3B6F,EAAIrF,KAAKC,MAAMT,EAAU,GACzB8F,EAAItF,KAAKC,MAAMR,EAAa,GACxB4F,EAAI,IAAM,IAAGA,GAAK,GAClBC,EAAI,IAAM,IAAGA,GAAK,GACtBC,EACEF,EAAID,EAAW,GAAGpF,KAAKC,MAAMD,KAAKgE,SAAWoB,EAAW,GAAGjE,SAC7DqE,EAAeF,EAAI,EAAE,GAAI,GAAI,EAAG,GAAGtF,KAAKC,MAAsB,EAAhBD,KAAKgE,WACnDyB,EACEJ,EAAID,EAAW,GAAGpF,KAAKC,MAAMD,KAAKgE,SAAWoB,EAAW,GAAGjE,SAC7DuE,EACEjG,EAAa6F,EAAI,CAAC,EAAG,EAAG,EAAG,GAAGtF,KAAKC,MAAsB,EAAhBD,KAAKgE,aAEhDoB,EAAaO,EAAclG,GAC3B4F,EAAIrF,KAAKC,MAAMT,EAAU,GACzB8F,EAAItF,KAAKC,MAAMR,EAAa,GACxB4F,EAAI,IAAM,IAAGA,GAAK,GAClBC,EAAI,IAAM,IAAGA,GAAK,GACtBC,EAAeF,EAAI,EAAE,GAAI,GAAI,EAAG,GAAGrF,KAAKC,MAAsB,EAAhBD,KAAKgE,WACnDwB,EACEF,EAAIF,EAAW,GAAGpF,KAAKC,MAAMD,KAAKgE,SAAWoB,EAAW,GAAGjE,SAC7DsE,EAAgBjG,EAAU6F,EAAI,CAAC,EAAG,EAAG,EAAG,GAAGrF,KAAKC,MAAsB,EAAhBD,KAAKgE,WAC3D0B,EACEJ,EAAIF,EAAW,GAAGpF,KAAKC,MAAMD,KAAKgE,SAAWoB,EAAW,GAAGjE,UAE/D,MAAO,CAACoE,EAAcC,EAAcC,EAAeC,GAxpB7BE,CAAmBX,EAAgBC,GACrDK,EAAeJ,EAAgB,GAC/BK,EAAeL,EAAgB,GAC/BM,EAAgBN,EAAgB,GAChCO,EAAgBP,EAAgB,GAikBtC,IAAMU,EAAqB,SAACpF,EAAM9B,GAChC,IAD0C,EACtCmH,EAAUrF,EAAKkD,QADuB,cAEzBhF,GAFyB,IAE1C,2BAAwB,CAAC,IAAhB2F,EAAe,QAClBvD,EAAON,EAAK6D,EAAK,IAAIA,EAAK,IAC1ByB,EAAO,2BACNhF,GADM,IAET5B,QAAQ,IAEV2G,EAAQxB,EAAK,IAAIA,EAAK,IAAMyB,GARY,8BAU1C,OAAOD,GAGHE,EAAyB,SAC7BC,EACAC,GAOA,IALA,IAAIhF,EAAsB,GACtBiF,EAAInG,KAAK8D,IACXmC,EAAyB9E,OACzB+E,EAA0B/E,QAEnBmC,EAAI,EAAGA,EAAI6C,EAAG7C,SACe8C,IAAhCH,EAAyB3C,IAC3BpC,EAAoBF,KAAKiF,EAAyB3C,SAEf8C,IAAjCF,EAA0B5C,IAC5BpC,EAAoBF,KAAKkF,EAA0B5C,IAGvD,OAAOpC,GAGT,SAASyE,EAAcnC,GAGrB,IAFA,IAAI6C,EAAc,GACdlC,EAAO,EACFb,EAAI,EAAGA,EAAIE,EAAM,EAAGF,GAAK,EAChC+C,EAAYrF,KAAKmD,GACjBA,GAAQ,EAEV,IAAImC,EAAc,GAClBnC,GAAQ,EACR,IAAK,IAAIb,EAAIE,EAAM,EAAGF,EAAIE,EAAM,EAAGF,GAAK,EACtCgD,EAAYtF,KAAKmD,GACjBA,GAAQ,EAEV,MAAO,CAACkC,EAAaC,GAwCRC,OArpBe,WAAO,IAAD,EACVC,mBAAS,IADC,mBAC3B/F,EAD2B,KACrBgG,EADqB,OAERD,mBAAS1B,OAAOC,YAFR,mBAE3BzF,EAF2B,KAEpBoH,EAFoB,OAGNF,mBAAS1B,OAAOE,aAHV,mBAG3BzF,EAH2B,KAGnBoH,EAHmB,OAIRH,mBAAS,IAJD,mBAI3BI,EAJ2B,KAIpBC,EAJoB,OAKsBL,oBAAS,GAL/B,mBAK3BM,EAL2B,KAKLC,EALK,OAMUP,oBAAS,GANnB,mBAM3BQ,EAN2B,KAMXC,GANW,QAOAT,mBAAS,IAPT,qBAO3BU,GAP2B,MAOhBC,GAPgB,SAQdX,mBAASvB,GAAtBzF,GAR2B,wBASXgH,mBAAStB,GAAzBzF,GAT2B,wBAUF+G,mBAAS,gBAVP,qBAU3BY,GAV2B,MAUjBC,GAViB,SAWVb,mBAAS,eAXC,qBAW3Bc,GAX2B,MAWrBC,GAXqB,SAYQf,mBAAS,CAACjB,EAAcC,IAZhC,qBAY3BgC,GAZ2B,MAYZC,GAZY,SAaIjB,mBAAS,CAACf,EAAcC,IAb5B,qBAa3BgC,GAb2B,MAadC,GAbc,SAcTnB,mBAAS,CAACjB,EAAaC,IAdd,qBAc3BoC,GAd2B,MAcrBC,GAdqB,SAeTrB,mBAAS,CAACf,EAAcC,IAff,qBAe3BoC,GAf2B,MAerBC,GAfqB,SAgBFvB,oBAAS,GAhBP,qBAgB3BwB,GAhB2B,MAgBlBC,GAhBkB,MAoBlCC,qBAAU,WACRpD,OAAOqD,iBAAiB,SAAUC,MAElC,IAAMtC,EAAUuC,GAAe7I,GAASC,IACxCgH,EAAQX,KACP,IAEH,IAAMsC,GAAmB,WACvBzB,EAAU7B,OAAOE,aACjB0B,EAAS5B,OAAOC,aAwCZuD,GAAsB,SAC1BC,EACArH,GAEwC,IAApCqH,EAAyBpH,QAC3B4F,GAAwB,GAE1B,IAJG,eAIMzD,GACP,GAAIA,IAAMiF,EAAyBpH,OAAS,EAU1C,OATAqH,YAAW,WACT,IAAI1C,EAAU2C,GACZhI,EACA8H,EACArH,GAEFuF,EAAQX,GACRiB,GAAwB,KACvBzD,GAAK,EAAIsD,IACN,CAAN,UAEF,IAAI7F,EAAOwH,EAAyBjF,GACpCkF,YAAW,WAETE,SAASC,eAAT,eAAgC5H,EAAKhC,IAArC,YAA4CgC,EAAK/B,MAAOqB,UACtD,4BACDiD,GAAK,EAAIsD,KAlBLtD,EAAI,EAAGA,EAAIiF,EAAyBpH,OAAQmC,IAAK,CAAC,IAAD,IAAjDA,GAAiD,oCAsBtDsF,GAAmB,SAAC1H,EAAqBqH,GAC7C,IAD0E,EACtEzC,EAAUrF,EAD4D,cAE1DqF,GAF0D,IAE1E,2BAAyB,CAAC,IAAD,EAAhB/G,EAAgB,sBACNA,GADM,IACvB,2BAAsB,CAAC,IAAdgC,EAAa,QAChBgF,EAAO,2BACNhF,GADM,IAET3B,WAAW,IAEb0G,EAAQ/E,EAAKhC,KAAKgC,EAAK/B,KAAO+G,GANT,gCAFiD,8BAW1EU,EAAQX,GACR,IAZ0E,eAYjExC,GACP,IAAIvC,EAAOG,EAAoBoC,GAC/B,GAAIA,IAAMpC,EAAoBC,OAI5B,OAHAqH,YAAW,WACTF,GAAoBC,EAA0BrH,KAC7CoC,EAAIsD,GACD,CAAN,UAEF4B,YAAW,WAETE,SAASC,eAAT,eAAgC5H,EAAKhC,IAArC,YAA4CgC,EAAK/B,MAAOqB,UACtD,sBACDiD,EAAIsD,IAZAtD,EAAI,EAAGA,GAAKpC,EAAoBC,OAAQmC,IAAK,CAAC,IAAD,IAA7CA,GAA6C,oCAsExD,IAAMmF,GAAuB,SAC3BhI,EACA8H,EACArH,GAEA,IADG,EACC4E,EAAUrF,EAAKkD,QADhB,cAEczC,GAFd,IAEH,2BAAsC,CAAC,IAA9BH,EAA6B,QACpC,KACGA,EAAKhC,MAAQ6I,GAAM,IAAM7G,EAAK/B,MAAQ4I,GAAM,IAC5C7G,EAAKhC,MAAQ+I,GAAM,IAAM/G,EAAK/B,MAAQ8I,GAAM,IAF/C,CAKA,IAAI/B,EAAO,2BACNhF,GADM,IAET3B,WAAW,IAEb0G,EAAQ/E,EAAKhC,KAAKgC,EAAK/B,KAAO+G,IAZ7B,kDAccwC,GAdd,IAcH,2BAA2C,CAAC,IAAnCxH,EAAkC,QACzC,GAAIA,EAAKhC,MAAQ+I,GAAM,IAAM/G,EAAK/B,MAAQ8I,GAAM,GAC9C,OAAOhC,EAET,IAAIC,EAAO,2BACNhF,GADM,IAET3B,WAAW,EACXC,YAAY,IAEdyG,EAAQ/E,EAAKhC,KAAKgC,EAAK/B,KAAO+G,GAvB7B,gCA2BL,SAAS8C,KACH/B,GAAwBE,IAG5BD,GAAwB,GACxByB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClC5G,ELpQL,SAAeT,EAAMC,EAAWC,GACnC,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIE,EAAiB,GACjBK,EAAsB,GAI1B,IAHAR,EAAUE,SAAW,EACrBC,EAAeG,KAAKN,GAEa,IAA1BG,EAAeM,QAAc,CAClCN,EAAeO,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEyH,cAAgBxH,EAAEwH,iBAClD,IAAIvH,EAAcV,EAAeW,QACjC,GAAID,IAAgBZ,EAAY,OAAOO,EAEvCK,EAAYnC,WAAY,EACxB8B,EAAoBF,KAAKO,GAEzB,IARkC,EAQ9BK,EAAaM,EAAcX,EAAad,GARV,cASZmB,GATY,IASlC,2BAAkC,CAAC,IAA1BE,EAAyB,QAC5BlB,EAAWW,EAAYX,SAAW,EAElCuB,EAA6BL,EAAWjB,IAC1CA,EAAekI,QAAQjH,GACvBA,EAAUlB,SAAWA,EACrBkB,EAAUgH,cACRlI,EAAWwB,EAAkBN,EAAWnB,GAC1CmB,EAAUG,aAAeV,GAChBX,EAAWkB,EAAUlB,WAC9BkB,EAAUlB,SAAWA,EACrBkB,EAAUgH,cACRlI,EAAWwB,EAAkBN,EAAWnB,GAC1CmB,EAAUG,aAAeV,IAtBK,+BA0BpC,OAAOL,EKiOuB8H,CAAMvI,EAAMC,EAAWC,GAC7C4H,ELpMH,SAA0C5H,GAG/C,IAFA,IAAI4H,EAA2B,GAC3BU,EAActI,EACK,OAAhBsI,GACLV,EAAyBQ,QAAQE,GACjCA,EAAcA,EAAYhH,aAE5B,OAAOsG,EK8LHW,CAAiCvI,GACnCiI,GAAiB1H,EAAqBqH,KACrC3B,IAGL,SAASuC,KACHrC,GAAwBE,IAG5BD,GAAwB,GACxByB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClC5G,EJnRL,SAA4BT,EAAMC,EAAWC,GAChD,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIE,EAAiB,GACjBK,EAAsB,GAE1B,IADAL,EAAeG,KAAKN,GACa,IAA1BG,EAAeM,QAAc,CAClC,IAAII,EAAcV,EAAeW,QACjC,IAAID,EAAYpC,OAAhB,CACA,GAAIoC,IAAgBZ,EAAY,OAAOO,EACvCA,EAAoBF,KAAKO,GACzBA,EAAYnC,WAAY,EACxB,IANkC,EAM9BuC,EAAsBI,EAAuBR,EAAad,GAN5B,cAOHkB,GAPG,IAOlC,2BAAoD,CAAC,IAA5CK,EAA2C,QAClDA,EAAmBC,aAAeV,EAC9BY,EAA6BH,EAAoBnB,IACnDA,EAAeG,KAAKgB,IAVU,gCAcpC,OAAOd,EI8PuBkI,CAC1B3I,EACAC,EACAC,GAEI4H,EJ7OH,SAAwC5H,GAG7C,IAFA,IAAI4H,EAA2B,GAC3BU,EAActI,EACK,OAAhBsI,GACLV,EAAyBQ,QAAQE,GACjCA,EAAcA,EAAYhH,aAE5B,OAAOsG,EIuOHc,CAA+B1I,GACjCiI,GAAiB1H,EAAqBqH,KACrC3B,IAGL,SAAS0C,KACHxC,GAAwBE,IAG5BD,GAAwB,GACxByB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClC5G,EHtSL,SAA0BT,EAAMC,EAAWC,GAC9C,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIE,EAAiB,GACjBK,EAAsB,GAE1B,IADAL,EAAeG,KAAKN,GACa,IAA1BG,EAAeM,QAAc,CAClC,IAAII,EAAcV,EAAeW,QACjC,IAAID,EAAYpC,OAAhB,CACA,GAAIoC,IAAgBZ,EAAY,OAAOO,EACvCA,EAAoBF,KAAKO,GACzBA,EAAYnC,WAAY,EACxB,IANkC,EAM9BuC,EAAsBI,EAAuBR,EAAad,GAN5B,cAOHkB,GAPG,IAOlC,2BAAoD,CAAC,IAA5CK,EAA2C,QAClDA,EAAmBC,aAAeV,EAClCV,EAAekI,QAAQ/G,IATS,gCAYpC,OAAOd,EGmRuBqI,CAAiB9I,EAAMC,EAAWC,GACxD4H,EHvQH,SAAwC5H,GAG7C,IAFA,IAAI4H,EAA2B,GAC3BU,EAActI,EACK,OAAhBsI,GACLV,EAAyBQ,QAAQE,GACjCA,EAAcA,EAAYhH,aAE5B,OAAOsG,EGiQHiB,CAA+B7I,GACjCiI,GAAiB1H,EAAqBqH,KACrC3B,IAGL,SAAS6C,KACH3C,GAAwBE,IAG5BD,GAAwB,GACxByB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClC5G,EFrTL,SAAmBT,EAAMC,EAAWC,GACvC,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIE,EAAiB,GACjBK,EAAsB,GAI1B,IAHAR,EAAUE,SAAW,EACrBC,EAAeG,KAAKN,GAEa,IAA1BG,EAAeM,QAAc,CAClCN,EAAeO,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEyH,cAAgBxH,EAAEwH,iBAClD,IAAIvH,EAAcV,EAAeW,QACjC,GAAID,IAAgBZ,EAAY,OAAOO,EAEvCK,EAAYnC,WAAY,EACxB8B,EAAoBF,KAAKO,GAEzB,IARkC,EAQ9BK,EAAaM,EAAcX,EAAad,GARV,cASZmB,GATY,IASlC,2BAAkC,CAAC,IAA1BE,EAAyB,QAC5BlB,EAAWW,EAAYX,SAAW,EAElCuB,EAA6BL,EAAWjB,IAC1CA,EAAekI,QAAQjH,GACvBA,EAAUlB,SAAWA,EACrBkB,EAAUgH,cAAgB1G,EAAkBN,EAAWnB,GACvDmB,EAAUG,aAAeV,GAChBX,EAAWkB,EAAUlB,WAC9BkB,EAAUlB,SAAWA,EACrBkB,EAAUgH,cAAgB1G,EAAkBN,EAAWnB,GACvDmB,EAAUG,aAAeV,IApBK,+BAwBpC,OAAOL,EEoRuBwI,CAAUjJ,EAAMC,EAAWC,GACjD4H,EFvPH,SAA8C5H,GAGnD,IAFA,IAAI4H,EAA2B,GAC3BU,EAActI,EACK,OAAhBsI,GACLV,EAAyBQ,QAAQE,GACjCA,EAAcA,EAAYhH,aAE5B,OAAOsG,EEiPHoB,CAAqChJ,GACvCiI,GAAiB1H,EAAqBqH,KACrC3B,IAGL,SAASgD,KACH9C,GAAwBE,IAG5BD,GAAwB,GACxByB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClC5G,EDpUL,SAAmCT,EAAMC,EAAWC,GACvD,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAET,IAAIkJ,EAAsB,GACtB5D,EAA2B,GAC3B6D,EAAuB,GACvB5D,EAA4B,GAMhC,IALAxF,EAAUE,SAAW,EACrBD,EAAWC,SAAW,EACtBiJ,EAAoB7I,KAAKN,GACzBoJ,EAAqB9I,KAAKL,GAGO,IAA/BkJ,EAAoB1I,QACY,IAAhC2I,EAAqB3I,QACrB,CACA0I,EAAoBzI,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEyH,cAAgBxH,EAAEwH,iBACvDgB,EAAqB1I,MAAK,SAACC,EAAGC,GAAJ,OAAUD,EAAEyH,cAAgBxH,EAAEwH,iBACxD,IAAIvG,EAAmBsH,EAAoBrI,QACvCgB,EAAoBsH,EAAqBtI,QAM7C,GAJAe,EAAiBnD,WAAY,EAC7BoD,EAAkBpD,WAAY,EAC9B6G,EAAyBjF,KAAKuB,GAC9B2D,EAA0BlF,KAAKwB,GAC3BF,EAAYC,EAAkBC,GAChC,MAAO,CAACyD,EAA0BC,GAA2B,GAI/D,IAfA,EAeItE,EAAaM,EAAcK,EAAkB9B,GAfjD,cAgBsBmB,GAhBtB,IAgBA,2BAAkC,CAAC,IAA1BE,EAAyB,QAChC,IAAKK,EAA6BL,EAAWgI,GAG3C,OAFA7D,EAAyBjF,KAAKuB,GAC9B2D,EAA0BlF,KAAKc,GACxB,CAACmE,EAA0BC,GAA2B,GAE/D,IAAItF,EAAW2B,EAAiB3B,SAAW,EAEvCuB,EAA6BL,EAAW+H,IAC1CA,EAAoBd,QAAQjH,GAC5BA,EAAUlB,SAAWA,EACrBkB,EAAUgH,cAAgB1G,EAAkBN,EAAWnB,GACvDmB,EAAUG,aAAeM,GAChB3B,EAAWkB,EAAUlB,WAC9BkB,EAAUlB,SAAWA,EACrBkB,EAAUgH,cAAgB1G,EAAkBN,EAAWnB,GACvDmB,EAAUG,aAAeM,IAhC7B,8BAqCAX,EAAaM,EAAcM,EAAmB/B,GArC9C,oBAsCsBmB,GAtCtB,IAsCA,2BAAkC,CAAC,IAA1BE,EAAyB,QAChC,IAAKK,EAA6BL,EAAW+H,GAG3C,OAFA5D,EAAyBjF,KAAKwB,GAC9ByD,EAAyBjF,KAAKc,GACvB,CAACmE,EAA0BC,GAA2B,GAE/D,IAAItF,EAAW4B,EAAkB5B,SAAW,EAExCuB,EAA6BL,EAAWgI,IAC1CA,EAAqBf,QAAQjH,GAC7BA,EAAUlB,SAAWA,EACrBkB,EAAUgH,cAAgB1G,EAAkBN,EAAWpB,GACvDoB,EAAUG,aAAeO,GAChB5B,EAAWkB,EAAUlB,WAC9BkB,EAAUlB,SAAWA,EACrBkB,EAAUgH,cAAgB1G,EAAkBN,EAAWpB,GACvDoB,EAAUG,aAAeO,IAtD7B,+BA0DF,MAAO,CAACyD,EAA0BC,GAA2B,GC0P/B6D,CAC1BtJ,EACAC,EACAC,GAEIsF,EAA2B/E,EAAoB,GAC/CgF,EAA4BhF,EAAoB,GAChD8I,EAAgB9I,EAAoB,IApK9C,SACE+E,EACAC,EACAqC,EACAyB,GAMA,IAJA,IAAI5G,EAAMpD,KAAK8D,IACbmC,EAAyB9E,OACzB+E,EAA0B/E,QAH5B,WAKSmC,GACP,IAAIT,EAAQoD,EAAyB3C,GACjCR,EAAQoD,EAA0B5C,GACtC,GAAIA,IAAM2C,EAAyB9E,OAYjC,OAXAqH,YAAW,WACT,IAAItH,EAAsB8E,EACxBC,EACAC,GAEE8D,EACF1B,GAAoBC,EAA0BrH,GAE9C6F,GAAwB,KAEzBzD,EAAIsD,GACD,CAAN,UAEF4B,YAAW,gBAEKpC,IAAVvD,IACF6F,SAASC,eAAT,eAAgC9F,EAAM9D,IAAtC,YAA6C8D,EAAM7D,MAAOqB,UACxD,0BACU+F,IAAVtD,IACF4F,SAASC,eAAT,eAAgC7F,EAAM/D,IAAtC,YAA6C+D,EAAM9D,MAAOqB,UACxD,uBACHiD,EAAIsD,IAzBAtD,EAAI,EAAGA,GAAKF,EAAKE,IAAK,CAAC,IAAD,IAAtBA,GAAsB,mCAgK7B2G,CACEhE,EACAC,ED/NC,SACLrD,EACAC,GAIA,IAFA,IAAIyF,EAA2B,GAC3BU,EAAcnG,EACK,OAAhBmG,GACLV,EAAyBvH,KAAKiI,GAC9BA,EAAcA,EAAYhH,aAG5B,IADAgH,EAAcpG,EACS,OAAhBoG,GACLV,EAAyBQ,QAAQE,GACjCA,EAAcA,EAAYhH,aAE5B,OAAOsG,EC0MH2B,CACEjE,EAAyBA,EAAyB9E,OAAS,GAC3D+E,EAA0BA,EAA0B/E,OAAS,IAM/D6I,KAEDpD,IAGL,SAASuD,KACP,IAAIrD,IAAwBE,EAA5B,CAGA,IAAK,IAAIjI,EAAM,EAAGA,EAAM0B,EAAKU,OAAQpC,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMyB,EAAK,GAAGU,OAAQnC,IAGjCD,IAAQ6I,GAAM,IAAM5I,IAAQ4I,GAAM,IAClC7I,IAAQ+I,GAAM,IAAM9I,IAAQ8I,GAAM,KAGrCY,SAASC,eAAT,eAAgC5J,EAAhC,YAAuCC,IAAOqB,UAAY,QAIhE,IAAMyF,EAAUuC,GAAe7I,GAASC,IACxCsH,GAAwB,GACxBE,IAAkB,GAClBR,EAAQX,IAGV,IAAMsE,GAAc,SAACzL,GACnB,IAD8B,IAAD,WACpB2E,GACP,GAAIA,IAAM3E,EAAMwC,OAOd,OANAqH,YAAW,WACT2B,KACA,IAAIrE,EAAUD,EAAmBpF,EAAM9B,GACvC8H,EAAQX,GACRmB,IAAkB,KACjB3D,EAAI4D,IACD,CAAN,UAEF,IAAI5C,EAAO3F,EAAM2E,GACbvC,EAAON,EAAK6D,EAAK,IAAIA,EAAK,IAC9BkE,YAAW,WAETE,SAASC,eAAT,eAAgC5H,EAAKhC,IAArC,YAA4CgC,EAAK/B,MAAOqB,UACtD,4BACDiD,EAAI4D,KAhBA5D,EAAI,EAAGA,GAAK3E,EAAMwC,OAAQmC,IAAK,CAAC,IAAD,IAA/BA,GAA+B,oCAoB1C,SAAS+G,KACHvD,GAAwBE,IAG5BC,IAAkB,GAClBuB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClCnJ,EC7YL,SAAoB8B,EAAMC,EAAWC,GACxC,IAAKD,IAAcC,GAAcD,IAAcC,EAC7C,OAAO,EAGT,IADA,IAAIhC,EAAQ,GACHI,EAAM,EAAGA,EAAM0B,EAAKU,OAAQpC,IACnC,IAAK,IAAIC,EAAM,EAAGA,EAAMyB,EAAK,GAAGU,OAAQnC,IAEnCD,IAAQ2B,EAAU3B,KAAOC,IAAQ0B,EAAU1B,KAC3CD,IAAQ4B,EAAW5B,KAAOC,IAAQ2B,EAAW3B,KAG5CgB,KAAKgE,SAAW,KAClBrF,EAAMqC,KAAK,CAACjC,EAAKC,IAKvB,OADAL,EAAMyC,MAAK,kBAAMpB,KAAKgE,SAAW,MAC1BrF,ED2XS2L,CAAW7J,EAAMC,EAAWC,GAC1CyJ,GAAYzL,KACXuI,KA0CL,IA8BMmB,GAAiB,SAAC7I,EAASC,GAE/B,IADA,IAAIgB,EAAO,GACF1B,EAAM,EAAGA,EAAMS,EAAU,EAAGT,IAAO,CAE1C,IADA,IAAIwL,EAAa,GACRvL,EAAM,EAAGA,EAAMS,EAAa,EAAGT,IACtCuL,EAAWvJ,KAAKwJ,GAAWzL,EAAKC,IAElCyB,EAAKO,KAAKuJ,GAEZ,OAAO9J,GAGH+J,GAAa,SAACzL,EAAKC,GACvB,MAAO,CACLD,MACAC,MACAC,QAASF,IAAQ6I,GAAM,IAAM5I,IAAQ4I,GAAM,GAC3C1I,SAAUH,IAAQ+I,GAAM,IAAM9I,IAAQ8I,GAAM,GAC5ClH,SAAUa,IACVqH,cAAerH,IACfrC,WAAW,EACXC,YAAY,EACZF,QAAQ,EACR8C,aAAc,OAIlB,OACE,sBAAK5B,UAAU,kBAAf,UACE,sBAAKA,UAAU,iBAAf,UACE,qBAAKA,UAAU,MAAf,SACA,yBAAQoK,SAAU,SAACrK,GAAD,OA7DC,SAACA,GACxBiH,GAAYjH,EAAMsK,OAAOC,OA4DQC,CAAiBxK,IAA9C,UACE,mDACA,8CACA,gDACA,iEACA,uBACA,wDACA,+DAGF,wBAAQyK,QA3DK,WAEA,aAAbzD,GAxPAN,GAAwBE,IAG5BD,GAAwB,GACxByB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClC5G,EAAsBV,EAASC,EAAMC,EAAWC,GAChD4H,ENtKH,SAA6C5H,GAGlD,IAFA,IAAI4H,EAA2B,GAC3BU,EAActI,EACK,OAAhBsI,GACLV,EAAyBQ,QAAQE,GACjCA,EAAcA,EAAYhH,aAE5B,OAAOsG,EMgKHuC,CAAoCnK,GACtCiI,GAAiB1H,EAAqBqH,KACrC3B,IA8OmB,iBAAbQ,GAA6ByB,KAChB,yBAAbzB,GAAqC+B,KACxB,uBAAb/B,GAAmCkC,KACtB,eAAblC,GAA2BqC,KACd,gCAAbrC,IACPwC,MAmD+BtJ,MAAO,CAAEyK,gBAAkB,UAAUC,MAAQ,QAASC,YAAc,UAAWC,QAAU,GAAtH,wBAGA,wBAAQL,QAASV,GAAW7J,MAAO,CAAEyK,gBAAkB,UAAUC,MAAQ,QAASC,YAAc,UAAUC,QAAU,EAAG5L,MAAO,IAAK6L,SAAW,WAAYC,KAAO,IAAjK,mBAGA,qBAAK/K,UAAU,MAAf,SACA,yBAAQoK,SAAU,SAACrK,GAAD,OAtEC,SAACA,GACxBmH,GAAQnH,EAAMsK,OAAOC,OAqEYU,CAAiBjL,IAA9C,UACE,iDACA,oDACA,mDACA,0DAGF,wBACEkL,KAAK,SACLhL,MAAO,CAAEyK,gBAAkB,UAAUC,MAAQ,QAAQC,YAAc,UAAWC,QAAU,EAAG5L,MAAQ,KACnGuL,QAlEa,WACN,gBAATvD,GAAwB+C,KACV,mBAAT/C,GA9DLR,GAAwBE,IAG5BC,IAAkB,GAClBuB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClCnJ,EAAQoE,EAAsBtC,EAAMC,EAAWC,GACrDyJ,GAAYzL,KACXuI,KAsDe,oBAATI,GArCLR,GAAwBE,IAG5BC,IAAkB,GAClBuB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClCnJ,EAAQ+F,EAAejE,EAAMC,EAAWC,GAC9CyJ,GAAYzL,KACXuI,KA6Be,kBAATI,KAnDLR,GAAwBE,IAG5BC,IAAkB,GAClBuB,YAAW,WACT,IAAM9H,EAAYD,EAAKmH,GAAM,IAAIA,GAAM,IACjCjH,EAAaF,EAAKqH,GAAM,IAAIA,GAAM,IAClCnJ,EAAQ4F,EAAa9D,EAAMC,EAAWC,GAC5CyJ,GAAYzL,KACXuI,OAqGC,2BASF,qBAAK7G,UAAU,MAAf,SACE,yBAAQC,MAAO,CAAEhB,MAAQ,KACrBuL,QAAS,SAACzK,GAAD,OA7FC,SAACA,GACnByG,EAASzG,EAAMsK,OAAOC,OACtBxD,GAAa/G,EAAMsK,OAAOC,OA2FAY,CAAYnL,IADlC,UAEE,wBAAQuK,MAAM,KAAd,kBACA,wBAAQA,MAAM,KAAd,oBACA,wBAAQA,MAAM,KAAd,0BAOJ,qBACEtK,UACEyG,GAAwBE,EAAiB,mBAAqB,OAFlE,SAIGvG,EAAK+K,KAAI,SAACzM,EAAK0M,GACd,OACE,8BACG1M,EAAIyM,KAAI,SAACzK,EAAM2K,GAAY,IAExB3M,EAOEgC,EAPFhC,IACAC,EAME+B,EANF/B,IACAC,EAKE8B,EALF9B,QACAC,EAIE6B,EAJF7B,SACAE,EAGE2B,EAHF3B,UACAC,EAEE0B,EAFF1B,WACAF,EACE4B,EADF5B,OAEF,OACE,cAAC,EAAD,CAEEJ,IAAKA,EACLC,IAAKA,EACLC,QAASA,EACTC,SAAUA,EACVE,UAAWA,EACXC,WAAYA,EACZF,OAAQA,EACRG,MAAOA,EACPC,OAAQA,EACRC,QAASA,GACTC,WAAYA,GACZE,WAAY,SAACY,GAAD,OAzfP,SAACA,GACtBA,EAAEoL,iBAwfiCC,CAAerL,IAClCb,YAAa,SAACU,GAAD,OAvfP,SAACA,EAAOrB,EAAKC,GAChCD,IAAQ6I,GAAM,IAAM5I,IAAQ4I,GAAM,GACnCH,GAAiB,CAAC1I,EAAKC,KAGvBiJ,IAAY,GACZN,GAAe,CAAC5I,EAAIC,KAifkB6M,CAAgBzL,EAAOrB,EAAKC,IACpDY,OAAQ,kBA9eP,SAACb,EAAKC,GACvB,IAAM8G,EAAUrF,EACV0D,EAAO2B,EAAQ/G,GAAKC,GACvBgJ,IACDD,GAAS,CAAChJ,EAAIC,IACd0J,SAASC,eAAT,eAAgC5J,EAAhC,YAAuCC,IAAOqB,UAAY,mBAC1DqI,SAASC,eAAT,eAAgCjB,GAAY,GAA5C,YAAkDA,GAAY,KAAMrH,UAClE,OACA8D,EAAKjF,UAAW,IAGlB2I,GAAS,CAAC9I,EAAIC,IAChB0J,SAASC,eAAT,eAAgC5J,EAAhC,YAAuCC,IAAOqB,UAAY,kBAC1DqI,SAASC,eAAT,eAAgCnB,GAAc,GAA9C,YAAoDA,GAAc,KAAMnH,UACtE,OACA8D,EAAKlF,SAAU,GAIjBgJ,IAAY,GACZnC,EAAQ/G,GAAKC,GAAOmF,EACpBsC,EAAQX,GAydsBgG,CAAW/M,EAAKC,KAdzB0M,OAbHD,YE9hBPM,GARqB,WAChC,OACI,mCACI,cAAC,GAAD,O,iCCLZ,IAAMC,GAAgB,YA6EPC,GA1Ea,SAACpI,EAAMqI,GAG3B,IAFJ,IAAMC,ECLF,SAAoBC,GAGxB,IAFA,IAAMD,EAAa,GACf9G,EAAI,EACA/B,EAAI,EAAGA,EAAI8I,EAAIjL,OAAQ,EAAImC,IAE/B,IADA,IAAI+I,EAAKD,EAAIjL,OAAS,EAAKmC,EACnBgJ,EAAI,EAAGA,EAAIF,EAAIjL,OAAQmC,EAAE,EAAGgJ,IAAI,CAMpC,GAJAH,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IAIpBF,EAAIE,GAAKF,EAAIE,EAAE,GAAG,CACjBH,EAAWnL,KAAK,EAAE,EAAEsL,EAAEA,EAAE,IACxBH,EAAWnL,KAAK,EAAE,EAAEsL,EAAEA,EAAE,IAExBH,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IACvBH,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IACvBjH,EAAI,EAGJ,IAAMlB,EAAOiI,EAAIE,GACjBF,EAAIE,GAAKF,EAAIE,EAAE,GACfF,EAAIE,EAAE,GAAKnI,OAKXgI,EAAWnL,KAAK,EAAE,EAAEsL,EAAEA,EAAE,IAIzBhJ,IAAM8I,EAAIjL,OAAS,GAAKmL,IAAMD,EAC7BF,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IAGnBA,IAAMD,EACVF,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IAEb,IAANjH,GACJ8G,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IACvBjH,EAAI,GAIJ8G,EAAWnL,KAAK,CAAC,EAAEsL,EAAEA,EAAE,IAKnC,OAAOH,ED5CYI,CAAW1I,GACpBT,EAAM+I,EAAWhL,OAAS,EAFiB,WAGzCmC,GACJ,IAAMkJ,EAAY9D,SAAS+D,uBAAuB,YAC5CC,EAAQP,EAAW7I,GAEzB,GADsBA,EAAE,IAAM,GAE1B,GAAgB,IAAboJ,EAAM,GAAS,CAClB,IAAMC,EAASR,EAAW7I,GACpBsJ,EAAYD,EAAO,GACnBE,EAAYF,EAAO,GACnBG,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0K,EAAS1H,EAAI,IAAM,EAhBjB,MAgBuC0I,GAC/CxD,YAAW,WACPsE,EAAY/B,gBAAkBC,EAC9B+B,EAAYhC,gBAAkBC,IAC/B1H,EAAE4I,QAEJ,GAAgB,IAAbQ,EAAM,GAAS,CACnB,IAAMC,EAASR,EAAW7I,GACpBsJ,EAAYD,EAAO,GACnBE,EAAYF,EAAO,GACnBG,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0K,EAAS1H,EAAI,IAAM,EAAI,SAAW0I,GAExCxD,YAAW,WACPsE,EAAY/B,gBAAkBC,EAC9B+B,EAAYhC,gBAAkBC,IAC/B1H,EAAE4I,QAEJ,GAAgB,IAAbQ,EAAM,GAAS,CACnB,IAAMC,EAASR,EAAW7I,GACpBsJ,EAAYD,EAAO,GACnBE,EAAYF,EAAO,GACnBG,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACzCkI,YAAW,WACPsE,EAAY/B,gBAAkBiB,GAC9Be,EAAYhC,gBAAkB,WAC/BzH,EAAE4I,QAEH,GAAgB,IAAbQ,EAAM,GAAS,CACpB,IAAMC,EAASR,EAAW7I,GACpBsJ,EAAYD,EAAO,GACnBE,EAAYF,EAAO,GACnBG,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACzCkI,YAAW,WACPsE,EAAY/B,gBAAkB,SAC9BgC,EAAYhC,gBAAkB,WAC/BzH,EAAE4I,SAKY,IAAbQ,EAAM,IACVlE,YAAW,WAAM,IAAD,cACoB2D,EAAW7I,GAD/B,GACJsJ,EADI,KACOC,EADP,KAENC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACrC6D,EAAO2I,EAAYvN,OACvBuN,EAAYvN,OAASwN,EAAYxN,OACjCwN,EAAYxN,OAAS4E,IAEvBb,EAAE4I,IAhEJ5I,EAAI,EAAGA,EAAEF,EAAM,EAAGE,IAAK,EAAvBA,IEPT,SAAS0J,GAAUnJ,GACtB,IAAMsI,EAAa,GAEnB,OADAc,GAAgBpJ,EAAM,EAAEA,EAAM1C,OAAS,EAAEgL,GAClCA,EAGJ,SAASc,GAAgBpJ,EAAMqJ,EAAMC,EAAIhB,GAW5C,GAVGe,GAASC,IACRhB,EAAWnL,KAAK,EAAE,EAAEkM,EAAMC,IAC1BhB,EAAWnL,KAAK,EAAE,EAAEkM,EAAMC,IACvBA,EAAI,IAAGA,EAAM,GACbD,EAAMrJ,EAAM1C,OAAS,IAAG+L,EAAQrJ,EAAM1C,OAAO,GAChDgL,EAAWnL,KAAK,CAAC,EAAEkM,EAAMC,KAK1BD,EAAMC,EAAI,CACT,IAAMC,EAMd,SAAmBvJ,EAAMqJ,EAAMC,EAAIhB,GAG/B,IAFA,IAAI7I,EAAI4J,EAEAZ,EAAIY,EAAOZ,GAAGa,EAAM,EAAGb,IAAI,CAC/B,IAAMe,EAAQxJ,EAAMsJ,GACpBhB,EAAWnL,KAAK,CAAC,EAAEsL,EAAEa,IAClBtJ,EAAMyI,IAAIe,GAETlB,EAAWnL,KAAK,IAChBmL,EAAWnL,KAAK,CAAC,EAAEsL,EAAEa,IAErBG,GAAKzJ,EAAMP,EAAEgJ,GACbH,EAAWnL,KAAK,CAAC,EAAEsC,EAAEgJ,IACrBH,EAAWnL,KAAK,CAAC,EAAEsC,EAAEgJ,IACrBH,EAAWnL,KAAK,CAAC,EAAEsC,EAAEgJ,IACrBhJ,MAGA6I,EAAWnL,KAAK,EAAE,EAAEsC,EAAEgJ,IACtBH,EAAWnL,KAAK,CAAC,EAAEsL,EAAEa,KAQ7B,OALAhB,EAAWnL,KAAK,CAAC,EAAEsC,EAAE6J,IACrBhB,EAAWnL,KAAK,CAAC,EAAEsC,EAAE6J,IACrBhB,EAAWnL,KAAK,CAAC,EAAEsC,EAAE6J,IAErBG,GAAKzJ,EAAMP,EAAE6J,GACN7J,EAjCYiK,CAAU1J,EAAMqJ,EAAMC,EAAIhB,GACzCc,GAAgBpJ,EAAMqJ,EAAME,EAAO,EAAEjB,GACrCc,GAAgBpJ,EAAMuJ,EAAO,EAAED,EAAIhB,IAmC3C,SAASmB,GAAKzJ,EAAOP,EAAGgJ,GACpB,IAAMnI,EAAON,EAAMP,GACnBO,EAAMP,GAAKO,EAAMyI,GACjBzI,EAAMyI,GAAKnI,ECxDf,IAAM6H,GAAgB,YAGhBwB,GAAc,SAiELC,GAhEY,SAAC5J,EAAMqI,GAE1B,IADA,IAAMC,EAAaa,GAAUnJ,GADmB,WAExCP,GACJ,IAAMkJ,EAAY9D,SAAS+D,uBAAuB,YAC5CiB,EAAgBpK,EAAI,IAAM,EAC1BqK,EAAUxB,EAAW7I,GAC3B,GAAGoK,EAAc,CACb,GAAkB,IAAfC,EAAQ,GAAS,CAAC,IAAD,cACexB,EAAW7I,GAD1B,GACRsJ,EADQ,KACEC,EADF,KAEVC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0K,EAAS1H,EAAI,IAAM,EAbrB,SAa2C0I,GAC/CxD,YAAW,WACPsE,EAAY/B,gBAAkBC,EAC9B+B,EAAYhC,gBAAkBC,IAC/B1H,EAAE4I,GAET,GAAmB,IAAhByB,EAAQ,GAAU,CAAC,IAAD,cACcxB,EAAW7I,GADzB,GACTsJ,EADS,KACCC,EADD,KAEXC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACzCkI,YAAW,WACPsE,EAAY/B,gBAAkByC,GAC9BT,EAAYhC,gBAAkByC,KAC/BlK,EAAE4I,QAEJ,GAAkB,IAAfyB,EAAQ,GACZnF,YAAW,WAAK,IAAD,cACqB2D,EAAW7I,GADhC,GACHsJ,EADG,KACQC,EADR,KAELE,EAAcP,EAAUK,GAAWvM,MACrBkM,EAAUI,GAAWtM,MAC7ByK,gBAAkByC,GAC9BT,EAAYhC,gBAAkBiB,KAC5B1I,EAAE4I,QAEP,GAAkB,IAAfyB,EAAQ,GAAS,CAAC,IAAD,cACUxB,EAAW7I,GADrB,GACbsJ,EADa,KACHC,EADG,KAIfC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0K,EAAS1H,EAAI,IAAM,EA5CrB,MA4C2C0I,GAC/CxD,YAAW,WACPsE,EAAY/B,gBAAkBC,EAC9B+B,EAAYhC,gBAAkBC,IAC/B1H,EAAE4I,SAKU,IAAfyB,EAAQ,IACZnF,YAAW,WAAM,IAAD,cACoB2D,EAAW7I,GAD/B,GACJsJ,EADI,KACOC,EADP,KAENC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACrC6D,EAAO2I,EAAYvN,OACvBuN,EAAYvN,OAASwN,EAAYxN,OACjCwN,EAAYxN,OAAS4E,IAEvBb,EAAE4I,IAzDJ5I,EAAI,EAAIA,EAAI6I,EAAWhL,OAAQmC,IAAK,EAApCA,ICPhB,IAoFea,GApFF,SAACN,EAAMqI,GAGlB,IAFA,IAAMC,ECFD,SAAuBtI,GAC1B,IAAIsI,EAAa,GACjByB,QAAQC,IAAIhK,GAEZ,IADA,IAAIP,EAAI,EACFA,EAAEO,EAAM1C,OAAO,EAAGmC,IAAI,CACxB,IAAIwK,EAASxK,EACb6I,EAAWnL,KAAK,CAAC,EAAEsC,IACnB6I,EAAWnL,KAAK,IAChBmL,EAAWnL,KAAK,IAChB,IAAI,IAAIsL,EAAEhJ,EAAE,EAAEgJ,EAAEzI,EAAM1C,OAAQmL,IAC1BH,EAAWnL,KAAK,CAAC,EAAEsL,EAAEwB,IAClBjK,EAAMyI,GAAGzI,EAAMiK,IACd3B,EAAWnL,KAAK,CAAC,EAAE8M,EAAOxB,IAC1BH,EAAWnL,KAAK,EAAE,EAAE8M,EAAOxB,IAC3BwB,EAASxB,IAGTH,EAAWnL,KAAK,IAChBmL,EAAWnL,KAAK,CAAC,EAAE8M,EAAOxB,KAGlCH,EAAWnL,KAAK,CAAC,EAAEsC,EAAEwK,IAGrB,IAAI3J,EAAON,EAAMP,GACjBO,EAAMP,GAAKO,EAAMiK,GACjBjK,EAAMiK,GAAU3J,EAChBgI,EAAWnL,KAAK,CAAC,EAAEsC,EAAEwK,IAClBxK,IAAMwK,EACL3B,EAAWnL,KAAK,EAAE,EAAEsC,IAGpB6I,EAAWnL,KAAK,CAAC,EAAEsC,EAAEwK,IAI7B,OADA3B,EAAWnL,KAAK,EAAE,EAAE6C,EAAM1C,OAAS,IAC5BgL,EDlCU4B,CAAclK,GADQ,WAGhCP,GACP,IAAMkJ,EAAY9D,SAAS+D,uBAAuB,YAC5CkB,EAAUxB,EAAW7I,GAE3B,GADsBA,EAAI,IAAM,GAE9B,GAAmB,IAAfqK,EAAQ,GAAU,CAAC,IAAD,cACaxB,EAAW7I,GADxB,GACXsJ,EADW,KACAC,EADA,KAEdC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0N,EAAW1K,EAAI,IAAM,EAAI,MAAQ,QACjC2K,EAAW3K,EAAI,IAAM,EAAI,MAAQ,YACvCkF,YAAW,WACTsE,EAAY/B,gBAAkBiD,EAC9BjB,EAAYhC,gBAAkBkD,IAC7B3K,EAAI4I,QAGJ,GAAkB,IAAfyB,EAAQ,GAAS,CAAC,IAElBb,EAAcN,EAFG,YACDL,EAAW7I,GADV,OAEkBhD,MAEzCkI,YAAW,WACTsE,EAAY/B,gBAFA,WAGXzH,EAAI4I,QAGN,GAAmB,IAAfyB,EAAQ,GAAU,CAAC,IAMhBO,EANe,cACc/B,EAAW7I,GADzB,GACVsJ,EADU,KACCC,EADD,KAEbC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0N,EAAW1K,EAAI,IAAM,EAAI,SAAW,SACpC2K,EAAW3K,EAAI,IAAM,EAAI,SAAW,YAE1C,GAAGA,IAAO6I,EAAWhL,OAAQ,EAEzB+M,EAAgB1B,EADIK,EAAY,GACOvM,MAG3CkI,YAAW,WACTsE,EAAY/B,gBAAkBiD,EAC9BjB,EAAYhC,gBAAkBkD,EAC3B3K,IAAO6I,EAAWhL,OAAQ,IAAI+M,EAAcnD,gBAAkB,YAChEzH,EAAI4I,QAEV,IAAoB,IAAhByB,EAAQ,GAAW,CAAC,IAAD,cACSxB,EAAW7I,GADpB,GACfsJ,EADe,KACJC,EADI,KAElBC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MAGzCkI,YAAW,WACTsE,EAAY/B,gBAFG,YAGfgC,EAAYhC,gBAJG,UAKdzH,EAAI4I,QAEN,IAAoB,IAAhByB,EAAQ,GAAW,CAAC,IAEnBb,EAAcN,EAFI,YACFL,EAAW7I,GADT,OAEiBhD,MAEzCkI,YAAW,WACTsE,EAAY/B,gBAFG,WAGdzH,EAAI4I,SAIR,GAAkB,IAAfyB,EAAQ,GAAS,CAAC,IAAD,cACexB,EAAW7I,GAD1B,GACRsJ,EADQ,KACEC,EADF,KAEVC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACzCkI,YAAW,WACN,IAAIrE,EAAO2I,EAAYvN,OACvBuN,EAAYvN,OAASwN,EAAYxN,OACjCwN,EAAYxN,OAAS4E,IACvBb,EAAG4I,KAzEN5I,EAAE,EAAGA,EAAI6I,EAAWhL,OAAQmC,IAAM,EAAlCA,IEFX,IA2De6K,GA3DgB,SAACtK,EAAMqI,GAIpC,IAHA,IAAMC,ECFD,SAAuBtI,GAC1B,IAAIP,EAAG8K,EAAK9B,EACNH,EAAa,GACnB,IAAK7I,EAAI,EAAGA,EAAIO,EAAM1C,OAAQmC,IAC9B,CAUI,IATA8K,EAAMvK,EAAMP,GACZgJ,EAAIhJ,EAAI,EACR6I,EAAWnL,KAAK,IAChBmL,EAAWnL,KAAK,CAAC,EAAEsC,IACnB6I,EAAWnL,KAAK,IAKTsL,GAAK,GAAKzI,EAAMyI,GAAK8B,GAExBjC,EAAWnL,KAAK,CAAC,EAAEsL,EAAE,EAAEA,IACvBH,EAAWnL,KAAK,CAAC,EAAEsL,EAAE,EAAEA,IACvBzI,EAAMyI,EAAI,GAAKzI,EAAMyI,GACrBH,EAAWnL,KAAK,CAAC,EAAEsL,EAAE,EAAEA,IACvBA,GAAQ,EAEZH,EAAWnL,KAAK,EAAE,EAAEsL,EAAE,EAAEhJ,IACxB6I,EAAWnL,KAAK,EAAE,EAAEsL,EAAE,EAAEhJ,IACxBO,EAAMyI,EAAI,GAAK8B,EACfjC,EAAWnL,KAAK,EAAE,EAAEsL,EAAE,EAAEhJ,IAG5B,OAAO6I,ED1BUkC,CAAcxK,GAE7ByK,EAAY,EAH2C,WAIlDhL,GACP,IAAMkJ,EAAY9D,SAAS+D,uBAAuB,YAC5CkB,EAAUxB,EAAW7I,GAE3B,GADsBA,EAAI,IAAM,GAE9B,GAAmB,IAAfqK,EAAQ,GAAU,CAAC,IAAD,cACaxB,EAAW7I,GADxB,GACXsJ,EADW,KACAC,EADA,KAEdC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0K,EAAQ1H,EAAI,IAAM,EAAI,MAAQ,YACpCkF,YAAW,WACTsE,EAAY/B,gBAAkBC,EAC9B+B,EAAYhC,gBAAkBC,IAC7B1H,EAAI4I,QACF,IAAoB,IAAhByB,EAAQ,GAAW,CAAC,IACpBf,EADmB,YACNT,EAAW7I,GADL,MAEtBwJ,EAAcN,EAAUI,GAAWtM,MACnC0K,EAAQ1H,EAAI,IAAM,EAAI,SAAW,YACvCkF,YAAW,WACTsE,EAAY/B,gBAAkBC,IAC7B1H,EAAI4I,QACF,IAAoB,IAAhByB,EAAQ,GAAW,CAAC,IAClBtI,EADiB,YACZ8G,EAAW7I,GADC,MAE5BkF,YAAW,WACT,IAAK,IAAI6D,EAAI,EAAGA,GAAKhH,EAAGgH,IAAK,CACVG,EAAUH,GAAG/L,MACrByK,gBAAkB,YAE5BzH,EAAI4I,SAGT,GAAmB,IAAfyB,EAAQ,GAAU,CAAC,IACZhB,EADW,YACDR,EAAW7I,GADV,MAEdiL,EAAW/B,EAAUG,GAAQrM,MACnCkI,YAAW,WACT8F,EAAYC,EAAShP,SACpB+D,EAAI4I,QACF,GAAmB,IAAfyB,EAAQ,GAAU,CAAC,IAAD,cACMxB,EAAW7I,GADjB,GAClBsJ,EADkB,KACPC,EADO,KAErBC,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACzCkI,YAAW,WACTsE,EAAYvN,OAASwN,EAAYxN,SAChC+D,EAAI4I,QACF,IAAoB,IAAhByB,EAAQ,GAAW,CAAC,IACpBf,EADmB,YACNT,EAAW7I,GADL,MAEtBwJ,EAAcN,EAAUI,GAAWtM,MACzCkI,YAAW,WACTsE,EAAYvN,OAAS+O,IACpBhL,EAAI4I,KAjDJ5I,EAAI,EAAGA,EAAI6I,EAAWhL,OAAQmC,IAAM,EAApCA,IENJ,SAASkL,GAAU3K,GACtB,IAAMsI,EAAa,GACnB,GAAGtI,EAAM1C,QAAU,EAAG,OAAO0C,EAE7B,IADA,IAAM4K,EAAiB,GACfnL,EAAE,EAAGA,EAAEO,EAAM1C,OAAQmC,IAAKmL,EAAezN,KAAK6C,EAAMP,IAE5D,OADAoL,GAAgB7K,EAAM,EAAGA,EAAM1C,OAAO,EAAGsN,EAAetC,GACjDA,EAGX,SAASuC,GACLC,EACAC,EACAC,EACAJ,EACAtC,GAEA,GAAGyC,IAAaC,EAAhB,CACA,IAAMC,EAAY9O,KAAKC,OAAO2O,EAAWC,GAAQ,GACjDH,GAAgBD,EAAeG,EAASE,EAAUH,EAAUxC,GAC5DuC,GAAgBD,EAAeK,EAAU,EAAED,EAAOF,EAAUxC,GAIhE,SACIwC,EACAC,EACAE,EACAD,EACAJ,EACAtC,GAEA,IAAIE,EAAIuC,EACJtL,EAAIsL,EACJtC,EAAIwC,EAAY,EACpB,KAAMxL,GAAKwL,GAAaxC,GAAIuC,GACxB1C,EAAWnL,KAAK,CAACsC,EAAEgJ,IAChBmC,EAAenL,IAAMmL,EAAenC,IACnCH,EAAWnL,KAAK,CAACqL,EAAEoC,EAAenL,KAClC6I,EAAWnL,KAAK,CAACsC,EAAEgJ,IACnBqC,EAAUtC,KAAOoC,EAAenL,OAEhC6I,EAAWnL,KAAK,CAACqL,EAAEoC,EAAenC,KAClCH,EAAWnL,KAAK,CAACsC,EAAEgJ,IACnBqC,EAAUtC,KAAOoC,EAAenC,MAIxC,KAAOhJ,GAAKwL,GACR3C,EAAWnL,KAAK,CAACsC,EAAEA,IACnB6I,EAAWnL,KAAK,CAACqL,EAAEoC,EAAenL,KAClC6I,EAAWnL,KAAK,CAACsC,EAAEA,IAEnBqL,EAAUtC,KAAOoC,EAAenL,KAGpC,KAAMgJ,GAAIuC,GACN1C,EAAWnL,KAAK,CAACsL,EAAEA,IACnBH,EAAWnL,KAAK,CAACqL,EAAGoC,EAAenC,KACnCH,EAAWnL,KAAK,CAACsL,EAAEA,IAEnBqC,EAAUtC,KAAOoC,EAAenC,KAxCpCyC,CAAQJ,EAAWC,EAASE,EAAWD,EAAOJ,EAAetC,IClBjE,IAwCe6C,GAvCY,SAACnL,EAAMqI,GAG9B,IAFA,IAAMC,EAAaqC,GAAU3K,GADuB,WAG3CP,GACP,IAAMkJ,EAAY9D,SAAS+D,uBAAuB,YAElD,GADsBnJ,EAAI,IAAM,EACb,CACjB,IAAMqJ,EAASR,EAAW7I,GACpBsJ,EAAYD,EAAO,GACnBE,EAAYF,EAAO,GACnBG,EAAcN,EAAUI,GAAWtM,MACnCyM,EAAcP,EAAUK,GAAWvM,MACnC0K,EAAQ1H,EAAI,IAAM,EAbR,MAa8B,YAC9CkF,YAAW,WACTsE,EAAY/B,gBAAkBC,EAC9B+B,EAAYhC,gBAAkBC,IAC7B1H,EAAI4I,QAEP1D,YAAW,WAAO,IAAD,cACgB2D,EAAW7I,GAD3B,GACRsJ,EADQ,KACGqC,EADH,KAEKzC,EAAUI,GAAWtM,MAC7Bf,OAAZ,UAAwB0P,EAAxB,QACC3L,EAAI4I,GAEN5I,GAAK6I,EAAWhL,OAAS,GAC1BqH,YAAW,WAEX,IADE,IAAM0G,EAAUxG,SAASyG,iBAAiB,aACnC7L,EAAI,EAAGA,EAAI4L,EAAQ/N,OAAQmC,IAAK,CACtB4L,EAAQ5L,GAAGhD,MACnByK,gBAAkB,YAE3BzH,EAAE4I,IA5BC5I,EAAI,EAAGA,EAAI6I,EAAWhL,OAAQmC,IAAM,EAApCA,IC+BE8L,GAnCa,WAC1B,OACE,sBAAK/O,UAAU,iBAAf,UACE,qBACEA,UAAU,WACVC,MAAO,CACLyK,gBAAiB,YACjBzL,MAAO,IACP+P,UAAW,SACXC,WAAa,OACbC,UAAY,EACZC,aAAe,GARnB,sBAaA,qBACEnP,UAAU,YACVC,MAAO,CACLyK,gBAAiB,MACjBzL,MAAO,IACP+P,UAAW,SACXrE,MAAQ,OACRwE,aAAe,EACfF,WAAa,QARjB,2BCiBSG,GAjCY,WACzB,OACE,sBAAKpP,UAAU,iBAAf,UACE,qBACEA,UAAU,UACVC,MAAO,CACLyK,gBAAiB,SACjBzL,MAAO,IACP+P,UAAW,SACXG,aAAe,EACfD,UAAY,EACZD,WAAa,QARjB,qBAaA,qBACEjP,UAAU,SACVC,MAAO,CACLyK,gBAAiB,SACjBzL,MAAO,IACP+P,UAAW,SACXrE,MAAQ,OACRwE,aAAe,EACfF,WAAa,QARjB,wBCJAI,GAAYC,aAAW,CAC3BC,KAAM,CACJtQ,MAAO,IACP6L,SAAW,WACX0E,OAAS,GAEXC,MAAM,CACJC,SAAW,GACX5E,SAAW,WACX6E,IAAM,EACNhF,MAAQ,QACRsE,WAAa,UA4MFW,GAxMW,WACxB,IAAMC,EAAUR,KADc,EAEJlJ,mBAAS,IAFL,mBAEvB3C,EAFuB,KAEhBsM,EAFgB,OAGJ3J,mBAAS,IAHL,mBAGvBmE,EAHuB,KAGhByF,EAHgB,OAIsB5J,mBAAS,GAJ/B,mBAIvB0F,EAJuB,KAIHmE,EAJG,OAKQ7J,mBAAS,cALjB,mBAKvB8J,EALuB,KAKVC,EALU,KA2B9B,SAASC,IAAuB,IAAD,EACwB1L,OACrD,MAAO,CACL2L,OAH2B,EACrB1L,WAGN2L,QAJ2B,EACD1L,aApB9BkD,qBAAU,WAAO,IACPwI,EAAYF,IAAZE,SAEY,WAEpB,IADE,IAAMvM,EAAO,GACNb,EAAI,EAAGA,EAAIqH,EAAOrH,IACzBa,EAAKnD,KAAK2P,EAAsB,EAAGD,EAAUA,EAAU,IAEzDP,EAAShM,GAET,IADA,IAAM+K,EAAUxG,SAASyG,iBAAiB,aACjC7L,EAAI,EAAGA,EAAI4L,EAAQ/N,OAAQmC,IAAK,CACtB4L,EAAQ5L,GAAGhD,MACnByK,gBAAkB,aAG7B6F,KACC,IAxB2B,MAqCFJ,IAApBE,EArCsB,EAqCtBA,QAASD,EArCa,EAqCbA,OACXI,EAAWJ,EAASA,EAAS,EAG7BK,EAAa,SAACC,GAClBnD,QAAQC,IAAI/I,OAAOE,YAAaF,OAAOC,YAGvC,IADA,IAAMZ,EAAO,GACJb,EAAI,EAAGA,EAAIyN,EAAiBzN,IACnCa,EAAKnD,KAAK2P,EAAsB,EAAGD,EAAUA,EAAU,IAEzDP,EAAShM,GAET,IADA,IAAM+K,EAAUxG,SAASyG,iBAAiB,aACjC7L,EAAI,EAAGA,EAAI4L,EAAQ/N,OAAQmC,IAAK,CACtB4L,EAAQ5L,GAAGhD,MACnByK,gBAAkB,cAKzB4F,EAAwB,SAACK,EAAKlN,GAClC,OAAO9D,KAAKC,MAAMD,KAAKgE,UAAYF,EAAMkN,EAAM,GAAKA,IAIhDC,EAAc,WAClBhF,GAAoBpI,EAAOqI,IAqD7B,OACE,sBAAK7L,UAAU,kBAAf,UACE,sBAAKA,UAAU,oBAAf,UACE,qBAAKC,MAAO,CAAE4Q,WAAa,IAA3B,SACE,qBAAK7Q,UAAU,MAAMC,MAAO,CAAE6Q,QAAU,SAAShG,SAAU,WAAY0E,OAAS,IAAhF,SACA,yBAAQpF,SAlCU,SAACrK,EAAOuK,GAChC0F,EAAsBjQ,EAAMsK,OAAOC,QAiC7B,UACE,wBAAQA,MAAM,IAAd,sBACA,wBAAQA,MAAM,KAAd,kBACA,wBAAQA,MAAM,MAAd,kBACA,wBAAQA,MAAM,OAAd,6BAIJ,sBAAKtK,UAAU,mBAAf,UAaE,cAAC+Q,GAAA,EAAD,CAAY/Q,UAAW6P,EAAQJ,MAA/B,kBAGA,cAACuB,GAAA,EAAD,CACEhR,UAAW6P,EAAQN,KACnBjF,MAAOA,EACPqG,IAAK,GACLlN,IAAK+M,EAAW,EAAI,GACpBpG,SAnEW,SAACrK,EAAOuK,GAC3ByF,EAASzF,GACTmG,EAAWnG,IAkEH2G,kBAAgB,yBAGpB,sBAAKjR,UAAU,mBAAf,UAEE,wBAASC,MAAO,CAACyK,gBAAkB,UAAWC,MAAQ,QAASC,YAAc,UAAUC,QAAU,GAAKL,QAAS,kBAAMiG,EAAWnG,IAAhI,uBACE,qBAAKtK,UAAU,MAAMC,MAAO,CAAE6Q,QAAU,UAAxC,SACF,yBAAQ1G,SApEgB,SAACrK,GAC/BmQ,EAAenQ,EAAMsK,OAAOC,QAmEtB,UACE,wBAAQ4G,UAAQ,EAAC5G,MAAM,aAAvB,yBAGA,wBAAQA,MAAM,gBAAd,4BACA,wBAAQA,MAAM,YAAd,wBACA,wBAAQA,MAAM,YAAd,wBACA,wBAAQA,MAAM,gBAAd,gCAGF,wBAASrK,MAAO,CAACyK,gBAAkB,UAAWC,MAAQ,QAASC,YAAc,UAAUC,QAAU,GAAKL,QA3EnF,WACzB,OAAQyF,GACN,IAAK,aACJW,IACC,MACF,IAAK,gBAjBP9C,GAAuBtK,EAAOqI,GAmB1B,MACF,IAAK,YA5BPuB,GAAmB5J,EAAOqI,GA8BtB,MACF,IAAK,YApCP8C,GAAmBnL,EAAOqI,GAsCtB,MACF,IAAK,gBA7BPsF,GAAuB3N,EAAOqI,GA+B1B,MACF,QACE+E,MAyDE,0BAEF,qBAAK5Q,UAAU,iBAAf,SACA,8BACA,cAAC,GAAD,QAIA,qBAAKA,UAAU,OAAf,SACA,cAAC,GAAD,SAKF,qBAAKA,UAAU,qBAAf,SACGwD,EAAM2H,KAAI,SAACiG,EAAQC,GAAT,OACT,qBACErR,UAAU,WAEVC,MAAO,CACLf,OAAO,GAAD,OAAKkS,EAAL,MACNnS,MAAOuR,EAAWlG,EAAQ,EAC1BgH,YAAa,EACb5G,gBAhMQ,cA2LL2G,YC7KFE,I,MAtCA,WACb,IAAMC,EACJ/M,OAAOC,WAAa,IAAM,uBAAyB,iBAErD,OACE,sBAAK1E,UAAU,2CAAf,UACE,mBAAGA,UAAU,uBAAb,SAAqCwR,IAcrC,qBAAKC,MAAM,2BAA2B5R,GAAG,yBAAzC,SACE,qBAAI4R,MAAM,qBAAV,UACE,oBAAIA,MAAM,kBAAV,SACE,cAAC,IAAD,CAAMA,MAAM,WAAWC,GAAG,IAA1B,wBAIF,oBAAID,MAAM,WAAV,SACE,cAAC,IAAD,CAAOA,MAAM,WAAWC,GAAG,eAA3B,qCCdGC,OAZf,WACE,OACE,eAAC,IAAD,WACE,cAAC,GAAD,IACA,eAAC,IAAD,WACA,cAAC,IAAD,CAAOC,OAAK,EAACC,KAAK,IAAIC,UAAWlC,KACjC,cAAC,IAAD,CAAQiC,KAAK,eAAeC,UAAWpG,YCA9BqG,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCAdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEFrK,SAASC,eAAe,SAM1ByJ,O","file":"static/js/main.6695e40e.chunk.js","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","import React from \"react\";\nimport \"./node.css\";\n\nconst Node = (props) => {\n  const {\n    row,\n    col,\n    isStart,\n    isFinish,\n    isWall,\n    isVisited,\n    isShortest,\n    width,\n    height,\n    numRows,\n    numColumns,\n    onDragStart,\n    onDragOver,\n    onDrop\n  } = props;\n\n  const extraClass = isStart\n    ? \"node node-start\"\n    : isFinish\n    ? \"node node-finish\"\n    : isWall\n    ? \"node-wall\"\n    : isShortest\n    ? \"node node-shortest-path\"\n    : isVisited\n    ? \"node node-visited\"\n    : \"node\";\n\n\n\n    const isPlace = isStart || isFinish;\n  const block = () => {\n    if (isPlace) {\n      return (\n        <div\n          id={`node-${row}-${col}`}\n          draggable\n          onDragStart={(event)=>onDragStart(event)}\n          className={`${extraClass}`}\n          style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\n        ></div>\n      );\n    } else {\n      return (\n        <div\n          id={`node-${row}-${col}`}\n          onDragOver={(e)=>onDragOver(e)}\n          onDrop={()=>onDrop()}\n          className={`node ${extraClass}`}\n          style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\n          \n        ></div>\n      )\n    }\n  }\n\n\n    let cellWidth = Math.floor((width - 15) / numColumns);\n    let cellHeight;\n    if (width > 1500) {\n      cellHeight = Math.floor((height - 70) / numRows);\n    } else if (width > 1000) {\n      cellHeight = Math.floor((height - 70) / numRows);\n    } else if (width > 500) {\n      cellHeight = Math.floor((height - 60) / numRows);\n    } else if (width > 0) {\n      cellHeight = Math.floor((height - 50) / numRows);\n    }\n\n    return (\n        <>\n        {block()}\n        </>\n         \n       \n      );\n};\n\nexport default Node;\n","export function dijkstra(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    startNode.distance = 0;\n    let unvisitedNodes = getNodes(grid);\n    let visitedNodesInOrder = [];\n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.distance - b.distance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      updateUnvisitedNeighbours(closestNode, grid);\n    }\n  }\n  \n  function getNodes(grid) {\n    let nodes = [];\n    for (let row of grid) {\n      for (let node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  function updateUnvisitedNeighbours(node, grid) {\n    let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.distance = node.distance + 1;\n      unvisitedNeighbour.previousNode = node;\n    }\n  }\n  \n  function getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n      .filter((neighbour) => !neighbour.isWall)\n      .filter((neighbour) => !neighbour.isVisited);\n  }\n  \n  export function getNodesInShortestPathOrderDijkstra(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function astar(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = []; //open list\n    let visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    unvisitedNodes.push(startNode);\n  \n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode === finishNode) return visitedNodesInOrder;\n  \n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n  \n      let neighbours = getNeighbours(closestNode, grid);\n      for (let neighbour of neighbours) {\n        let distance = closestNode.distance + 1;\n        //f(n) = g(n) + h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n          unvisitedNodes.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance =\n            distance + manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance =\n            distance + manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  function manhattenDistance(node, finishNode) {\n    let x = Math.abs(node.row - finishNode.row);\n    let y = Math.abs(node.col - finishNode.col);\n    return x + y;\n  }\n  \n  export function getNodesInShortestPathOrderAstar(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function breadthFirstSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = [];\n    let visitedNodesInOrder = [];\n    unvisitedNodes.push(startNode);\n    while (unvisitedNodes.length !== 0) {\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      visitedNodesInOrder.push(closestNode);\n      closestNode.isVisited = true;\n      let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n      for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.previousNode = closestNode;\n        if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n          unvisitedNodes.push(unvisitedNeighbour);\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function depthFirstSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = [];\n    let visitedNodesInOrder = [];\n    unvisitedNodes.push(startNode);\n    while (unvisitedNodes.length !== 0) {\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      visitedNodesInOrder.push(closestNode);\n      closestNode.isVisited = true;\n      let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n      for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.previousNode = closestNode;\n        unvisitedNodes.unshift(unvisitedNeighbour);\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\n  }\n  \n  export function getNodesInShortestPathOrderDFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","export function greedyBFS(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = []; //open list\n    let visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    unvisitedNodes.push(startNode);\n  \n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode === finishNode) return visitedNodesInOrder;\n  \n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n  \n      let neighbours = getNeighbours(closestNode, grid);\n      for (let neighbour of neighbours) {\n        let distance = closestNode.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n          unvisitedNodes.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(node, finishNode) {\n    let x = Math.abs(node.row - finishNode.row);\n    let y = Math.abs(node.col - finishNode.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","export function bidirectionalGreedySearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodesStart = [];\n    let visitedNodesInOrderStart = [];\n    let unvisitedNodesFinish = [];\n    let visitedNodesInOrderFinish = [];\n    startNode.distance = 0;\n    finishNode.distance = 0;\n    unvisitedNodesStart.push(startNode);\n    unvisitedNodesFinish.push(finishNode);\n  \n    while (\n      unvisitedNodesStart.length !== 0 &&\n      unvisitedNodesFinish.length !== 0\n    ) {\n      unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n      unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNodeStart = unvisitedNodesStart.shift();\n      let closestNodeFinish = unvisitedNodesFinish.shift();\n  \n      closestNodeStart.isVisited = true;\n      closestNodeFinish.isVisited = true;\n      visitedNodesInOrderStart.push(closestNodeStart);\n      visitedNodesInOrderFinish.push(closestNodeFinish);\n      if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n  \n      //Start side search\n      let neighbours = getNeighbours(closestNodeStart, grid);\n      for (let neighbour of neighbours) {\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n          visitedNodesInOrderStart.push(closestNodeStart);\n          visitedNodesInOrderFinish.push(neighbour);\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        }\n        let distance = closestNodeStart.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n          unvisitedNodesStart.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNodeStart;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNodeStart;\n        }\n      }\n  \n      //Finish side search\n      neighbours = getNeighbours(closestNodeFinish, grid);\n      for (let neighbour of neighbours) {\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n          visitedNodesInOrderStart.push(closestNodeFinish);\n          visitedNodesInOrderStart.push(neighbour);\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        }\n        let distance = closestNodeFinish.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n          unvisitedNodesFinish.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n          neighbour.previousNode = closestNodeFinish;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n          neighbour.previousNode = closestNodeFinish;\n        }\n      }\n    }\n    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n  }\n  \n  function isNeighbour(closestNodeStart, closestNodeFinish) {\n    let rowStart = closestNodeStart.row;\n    let colStart = closestNodeStart.col;\n    let rowFinish = closestNodeFinish.row;\n    let colFinish = closestNodeFinish.col;\n    if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n    if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n    if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n    if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n    return false;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(nodeA, nodeB) {\n    let x = Math.abs(nodeA.row - nodeB.row);\n    let y = Math.abs(nodeA.col - nodeB.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","import React, { useState, useEffect } from \"react\";\nimport Node from \"./node/node\";\nimport \"./PathFindingVisualizer.css\";\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"./algorithm/dijkstra\";\nimport { astar, getNodesInShortestPathOrderAstar } from \"./algorithm/astar\";\nimport {\n  breadthFirstSearch,\n  getNodesInShortestPathOrderBFS,\n} from \"./algorithm/breadthFirstSearch\";\n\nimport {\n  depthFirstSearch,\n  getNodesInShortestPathOrderDFS,\n} from \"./algorithm/depthFirstSearch\";\nimport {\n  greedyBFS,\n  getNodesInShortestPathOrderGreedyBFS,\n} from \"./algorithm/greedyBestFirstSearch\";\nimport {\n  bidirectionalGreedySearch,\n  getNodesInShortestPathOrderBidirectionalGreedySearch,\n} from \"./algorithm/bidirectionalGreedySearch\";\n\nimport { randomMaze } from \"./mazeAlgorithms/randomMaze\";\nimport { recursiveDivisionMaze } from \"./mazeAlgorithms/recursizeDivision\";\nimport { verticalMaze } from \"./mazeAlgorithms/verticalMaze\";\nimport { horizontalMaze } from \"./mazeAlgorithms/horizontalMaze\";\n\nconst initialNum = getInitialNum(window.innerWidth-100, window.innerHeight-100);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nconst PathFindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n  const [speed, setSpeed] = useState(10);\n  const [visualizingAlgorithm, setVisualizingAlgorithm] = useState(false);\n  const [generatingMaze, setGeneratingMaze] = useState(false);\n  const [mazeSpeed, setMazeSpeed] = useState(10);\n  const [numRows, ] = useState(initialNumRows);\n  const [numColumns, ] = useState(initialNumColumns);\n  const [currAlgo, setCurrAlgo] = useState(\"A* algorithm\");\n  const [maze, setMaze] = useState(\"Random Maze\");\n  const [dragStartData, setDragStartData] = useState([startNodeRow, startNodeCol]);\n  const [dragEndData, setDragEndData] = useState([finishNodeRow,finishNodeCol])\n  const [sNode,setSNode] = useState([startNodeRow,startNodeCol]);\n  const [fNode,setFNode] = useState([finishNodeRow,finishNodeCol])\n  const [isTarget,setIsTarget]  = useState(false)\n  \n\n\n  useEffect(() => {\n    window.addEventListener(\"resize\", updateDimensions());\n    // eslint-disable-next-line\n    const newGrid = getInitialGrid(numRows, numColumns);// eslint-disable-next-line\n    setGrid(newGrid);\n  }, []);\n\n  const updateDimensions = () => {\n    setHeight(window.innerHeight);\n    setWidth(window.innerWidth);\n  };\n\n  const handleDragOver = (e) => {\n    e.preventDefault();\n  };\n  const handleDragStart = (event, row, col) => {\n    if(row === sNode[0] && col === sNode[1]){\n      setDragStartData([row, col]);\n    }\n    else{\n      setIsTarget(true)\n      setDragEndData([row,col]);\n    }\n  };\n\n  const handleDrop = (row, col) => {\n    const newGrid = grid;\n    const temp = newGrid[row][col];\n    if(isTarget){\n      setFNode([row,col])\n      document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n      document.getElementById(`node-${dragEndData[0]}-${dragEndData[1]}`).className =\n        \"node\";\n        temp.isFinish = true;\n    }\n    else{\n      setSNode([row,col]);\n    document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n    document.getElementById(`node-${dragStartData[0]}-${dragStartData[1]}`).className =\n      \"node\";\n      temp.isStart = true;\n\n    }\n    \n    setIsTarget(false);\n    newGrid[row][col] = temp;\n    setGrid(newGrid);\n  };\n\n  const animateShortestPath = (\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    if (nodesInShortestPathOrder.length === 1) {\n      setVisualizingAlgorithm(false);\n    }\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          setGrid(newGrid);\n          setVisualizingAlgorithm(false);\n        }, i * (3 * speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * speed));\n    }\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = grid;\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    setGrid(newGrid);\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * speed);\n    }\n  };\n\n  function animateBidirectionalAlgorithm(\n    visitedNodesInOrderStart,\n    visitedNodesInOrderFinish,\n    nodesInShortestPathOrder,\n    isShortedPath\n  ) {\n    let len = Math.max(\n      visitedNodesInOrderStart.length,\n      visitedNodesInOrderFinish.length\n    );\n    for (let i = 1; i <= len; i++) {\n      let nodeA = visitedNodesInOrderStart[i];\n      let nodeB = visitedNodesInOrderFinish[i];\n      if (i === visitedNodesInOrderStart.length) {\n        setTimeout(() => {\n          let visitedNodesInOrder = getVisitedNodesInOrder(\n            visitedNodesInOrderStart,\n            visitedNodesInOrderFinish\n          );\n          if (isShortedPath) {\n            animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n          } else {\n            setVisualizingAlgorithm(true);\n          }\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited nodes\n        if (nodeA !== undefined)\n          document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\n            \"node node-visited\";\n        if (nodeB !== undefined)\n          document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\n            \"node node-visited\";\n      }, i * speed);\n    }\n  }\n\n  function visualizeDijkstra() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDijkstra(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  const updateNodesForRender = (\n    grid,\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    let newGrid = grid.slice();\n    for (let node of visitedNodesInOrder) {\n      if (\n        (node.row === sNode[0] && node.col === sNode[1]) ||\n        (node.row === fNode[0] && node.col === fNode[1])\n      )\n        continue;\n      let newNode = {\n        ...node,\n        isVisited: true,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n    for (let node of nodesInShortestPathOrder) {\n      if (node.row === fNode[0] && node.col === fNode[1]) {\n        return newGrid;\n      }\n      let newNode = {\n        ...node,\n        isVisited: false,\n        isShortest: true,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  };\n\n  function visualizeAStar() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = astar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderAstar(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeBFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = breadthFirstSearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderBFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeDFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeGreedyBFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderGreedyBFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeBidirectionalGreedySearch() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = bidirectionalGreedySearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const visitedNodesInOrderStart = visitedNodesInOrder[0];\n      const visitedNodesInOrderFinish = visitedNodesInOrder[1];\n      const isShortedPath = visitedNodesInOrder[2];\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderBidirectionalGreedySearch(\n          visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n          visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\n        );\n      animateBidirectionalAlgorithm(\n        visitedNodesInOrderStart,\n        visitedNodesInOrderFinish,\n        nodesInShortestPathOrder,\n        isShortedPath\n      );\n    }, speed);\n  }\n\n  function clearGrid() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          !(\n            (row === sNode[0] && col === sNode[1]) ||\n            (row === fNode[0] && col === fNode[1])\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(numRows, numColumns);\n    setVisualizingAlgorithm(false);\n    setGeneratingMaze(false);\n    setGrid(newGrid);\n  }\n\n  const animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          clearGrid();\n          let newGrid = getNewGridWithMaze(grid, walls);\n          setGrid(newGrid);\n          setGeneratingMaze(false);\n        }, i * mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * mazeSpeed);\n    }\n  };\n\n  function generateRandomMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = randomMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateRecursiveDivisionMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateVerticalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateHorizontalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  const handleAlgoChange = (event) => {\n    setCurrAlgo(event.target.value);\n  };\n  const handleSpeed = (event) =>{\n    setSpeed(event.target.value)\n    setMazeSpeed(event.target.value)\n  }\n\n  const handleMazeChange = (event) => {\n    setMaze(event.target.value);\n  };\n\n  const visualizer = () => {\n   \n    if (currAlgo === \"Dijkstra\") visualizeDijkstra();\n    else if (currAlgo === \"A* algorithm\") visualizeAStar();\n    else if (currAlgo === \"Breadth First Search\") visualizeBFS();\n    else if (currAlgo === \"Depth First Search\") visualizeDFS();\n    else if (currAlgo === \"Greedy BFS\") visualizeGreedyBFS();\n    else if (currAlgo === \"Bidirectional Greedy Search\")\n      visualizeBidirectionalGreedySearch();\n  };\n  const generateMaze = () => {\n    if (maze === \"Random Maze\") generateRandomMaze();\n    else if (maze === \"Recursive Maze\") generateRecursiveDivisionMaze();\n    else if (maze === \"Horizontal Maze\") generateHorizontalMaze();\n    else if (maze === \"Vertical Maze\") generateVerticalMaze();\n  };\n\n\n  const getInitialGrid = (numRows, numColumns) => {\n    let grid = [];\n    for (let row = 0; row < numRows - 3; row++) {\n      let currentRow = [];\n      for (let col = 0; col < numColumns - 5; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n  \n  const createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === sNode[0] && col === sNode[1],\n      isFinish: row === fNode[0] && col === fNode[1],\n      distance: Infinity,\n      totalDistance: Infinity,\n      isVisited: false,\n      isShortest: false,\n      isWall: false,\n      previousNode: null,\n    };\n  };\n\n  return (\n    <div className=\"container-fluid\">\n      <div className=\"info-container\">\n        <div className=\"box\">\n        <select onChange={(event) => handleAlgoChange(event)}>\n          <option> A* algorithm</option>\n          <option>Dijkstra</option>\n          <option>Greedy BFS</option>\n          <option>Bidirectional Greedy Search</option>\n          <hr />\n          <option>Depth First Search</option>\n          <option>Breadth First Search</option>\n        </select>\n        </div>\n        <button onClick={visualizer} style={{ backgroundColor : \"#228b22\",color : \"white\", borderColor : \"#228b22\", padding : 8}}>\n          VISUALIZER\n        </button>\n        <button onClick={clearGrid} style={{ backgroundColor : \"#f54e42\",color : \"white\", borderColor : \"#f54e42\",padding : 8, width: 170, position : \"relative\", left : 13}}>\n          CLEAR\n        </button>\n        <div className=\"box\">\n        <select onChange={(event) => handleMazeChange(event)} >\n          <option>Random Maze</option>\n          <option>Recursive Maze</option>\n          <option>Vertical Maze</option>\n          <option>Horizontal Maze</option>\n        </select>\n        </div>\n        <button\n          type=\"button\"\n          style={{ backgroundColor : \"#228b22\",color : \"white\",borderColor : \"#228b22\", padding : 8, width : 200}}\n          onClick={generateMaze}\n        >\n          GENERATE MAZE\n        </button>\n\n      {/* new button for speed handling */}\n      <div className=\"box\">\n        <select style={{ width : 100,\n         }} onClick={(event)=>handleSpeed(event)}>\n          <option value=\"50\">Slow</option>\n          <option value=\"30\">Medium</option>\n          <option value=\"10\">Fast</option>\n          \n        </select>\n        </div>\n      </div>\n\n\n      <div\n        className={\n          visualizingAlgorithm || generatingMaze ? \"grid-visualizing\" : \"grid\"\n        }>\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId}>\n              {row.map((node, nodeId) => {\n                const {\n                  row,\n                  col,\n                  isStart,\n                  isFinish,\n                  isVisited,\n                  isShortest,\n                  isWall,\n                } = node;\n                return (\n                  <Node\n                    key={nodeId}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isVisited={isVisited}\n                    isShortest={isShortest}\n                    isWall={isWall}\n                    width={width}\n                    height={height}\n                    numRows={numRows}\n                    numColumns={numColumns}\n                    onDragOver={(e) => handleDragOver(e)}\n                    onDragStart={(event) => handleDragStart(event, row, col)}\n                    onDrop={() => handleDrop(row, col)}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10) - 5;\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth) - 5;\n  return [numRows, numColumns];\n}\n\n\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getVisitedNodesInOrder = (\n  visitedNodesInOrderStart,\n  visitedNodesInOrderFinish\n) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(\n    visitedNodesInOrderStart.length,\n    visitedNodesInOrderFinish.length\n  );\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow =\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol =\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol =\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nexport default PathFindingVisualizer;\n","export function randomMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let walls = [];\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          (row === startNode.row && col === startNode.col) ||\n          (row === finishNode.row && col === finishNode.col)\n        )\n          continue;\n        if (Math.random() < 0.33) {\n          walls.push([row, col]);\n        }\n      }\n    }\n    walls.sort(() => Math.random() - 0.5);\n    return walls;\n  }\n  ","import React from 'react'\nimport PathFindingVisualizer from \"../PathFindingVisualizer/PathFindingVisualizer\"\n\nconst PathFindingVisualizerScreen = () => {\n    return (\n        <>\n            <PathFindingVisualizer />\n        </>\n    )\n}\n\nexport default PathFindingVisualizerScreen\n","import { bubbleSort } from '../SortingAlgorithms/bubbleSort'\nconst PRIMARY_COLOR = 'turquoise'\nconst SECONDARY_COLOR = 'red'\n\nconst bubbleSortAnimation = (array,ANIMATION_SPEED_MS) =>{\n    const animations = bubbleSort(array)\n        const len = animations.length - 1\n        for(let i = 0; i<len + 1; i++){\n            const arrayBars = document.getElementsByClassName(\"arraybar\")\n            const child = animations[i]\n            const isColorChange = i%3 !== 1\n            if(isColorChange){\n                if(child[0] === 0){\n                const barIdx = animations[i]\n                const barOneIdx = barIdx[1]\n                const barTwoIdx = barIdx[2]\n                const barOneStyle = arrayBars[barOneIdx].style\n                const barTwoStyle = arrayBars[barTwoIdx].style\n                const color =  i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR\n                setTimeout(()=>{\n                    barOneStyle.backgroundColor = color\n                    barTwoStyle.backgroundColor = color\n                }, i*ANIMATION_SPEED_MS)\n            }\n            else if(child[0] === 4){\n                const barIdx = animations[i]\n                const barOneIdx = barIdx[1]\n                const barTwoIdx = barIdx[2]\n                const barOneStyle = arrayBars[barOneIdx].style\n                const barTwoStyle = arrayBars[barTwoIdx].style\n                const color =  i % 3 === 0 ? \"yellow\" : PRIMARY_COLOR\n\n                setTimeout(()=>{\n                    barOneStyle.backgroundColor = color\n                    barTwoStyle.backgroundColor = color\n                }, i*ANIMATION_SPEED_MS)\n            }\n            else if(child[0] === 2){\n                const barIdx = animations[i]\n                const barOneIdx = barIdx[1]\n                const barTwoIdx = barIdx[2]\n                const barOneStyle = arrayBars[barOneIdx].style\n                const barTwoStyle = arrayBars[barTwoIdx].style\n                setTimeout(()=>{\n                    barOneStyle.backgroundColor = PRIMARY_COLOR\n                    barTwoStyle.backgroundColor = \"purple\"\n                }, i*ANIMATION_SPEED_MS)\n            }\n             else if(child[0] === 3){\n                const barIdx = animations[i]\n                const barOneIdx = barIdx[1]\n                const barTwoIdx = barIdx[2]\n                const barOneStyle = arrayBars[barOneIdx].style\n                const barTwoStyle = arrayBars[barTwoIdx].style\n                setTimeout(()=>{\n                    barOneStyle.backgroundColor = \"purple\"\n                    barTwoStyle.backgroundColor = \"purple\"\n                }, i*ANIMATION_SPEED_MS)\n            }\n\n\n            }\n            else if(child[0] === 1){\n                setTimeout(() =>{\n                    const [,barOneIdx, barTwoIdx] = animations[i]\n                    const barOneStyle = arrayBars[barOneIdx].style\n                    const barTwoStyle = arrayBars[barTwoIdx].style\n                    let temp = barOneStyle.height\n                    barOneStyle.height = barTwoStyle.height\n                    barTwoStyle.height = temp\n\n                },i*ANIMATION_SPEED_MS)\n            }\n            \n        }\n\n}\n\nexport default bubbleSortAnimation","export  function bubbleSort(arr){\n    const animations = []\n    let x = 1\n    for(let i = 0; i < arr.length -1 ; i++){\n        let k = (arr.length - 2 )- i\n        for(let j = 0; j < arr.length -i-1; j++){\n            //comparing color\n            animations.push([0,j,j+1])\n            \n           \n            \n            if(arr[j] > arr[j+1]){\n                animations.push([-2,j,j+1])\n                animations.push([-2,j,j+1])\n\n                animations.push([4,j,j+1])\n                animations.push([1,j,j+1])\n                x = 0\n\n                \n                const temp = arr[j]\n                arr[j] = arr[j+1]\n                arr[j+1] = temp\n                \n            }\n            else{\n                \n                animations.push([-1,j,j+1])\n            }\n\n            \n            if(i === arr.length - 2 && j === k){\n                animations.push([3,j,j+1])\n            }\n            //final postion \n            else if(j === k){\n                animations.push([2,j,j+1])\n            }\n            else if(x === 0){\n                animations.push([4,j,j+1])\n                x = 1\n            }\n            //comparing uncolor\n            else {\n                animations.push([0,j,j+1])\n            }\n\n        }\n    }\n    return animations;\n}\n\n\n","export function quickSort(array){\n    const animations = []\n    quickSortHelper(array,0,array.length - 1,animations)\n    return animations\n}\n\nexport function quickSortHelper(array,start,end,animations){\n    if(start >= end){\n        animations.push([-1,start,end])\n        animations.push([-1,start,end]) \n        if(end<0) end = 0\n        if(start>array.length - 1) start = array.length-1\n        animations.push([3,start,end])\n\n\n    }\n\n    if(start<end){\n        const pIndex = partition(array,start,end,animations)\n        quickSortHelper(array,start,pIndex-1,animations)\n        quickSortHelper(array,pIndex+1,end,animations)\n    }\n}\n\nfunction partition(array,start,end,animations){\n    let i = start\n\n    for(let j = start; j<=end - 1; j++){\n        const pivot = array[end]\n        animations.push([0,j,end])\n        if(array[j]<=pivot){\n\n            animations.push([])\n            animations.push([0,j,end])\n            \n            swap(array,i,j)\n            animations.push([4,i,j])\n            animations.push([1,i,j])\n            animations.push([4,i,j])\n            i++\n        }\n        else{\n            animations.push([-1,i,j])\n            animations.push([0,j,end])\n        }       \n    }\n    animations.push([4,i,end])\n    animations.push([1,i,end])\n    animations.push([2,i,end])\n\n    swap(array,i,end)\n    return i\n}\n\n\nfunction swap(array, i, j){\n    const temp = array[i]\n    array[i] = array[j]\n    array[j] = temp\n}","import { quickSort } from \"../SortingAlgorithms/quickSort\";\n\nconst PRIMARY_COLOR = 'turquoise'\nconst SECONDARY_COLOR = 'red'\nconst COMPARING_COLOR = 'yellow'\nconst FINAL_COLOR = 'purple'\nconst quickSortAnimation = (array,ANIMATION_SPEED_MS) =>{\n        const animations = quickSort(array)        \n        for(let i = 0 ; i < animations.length; i++){\n            const arrayBars = document.getElementsByClassName(\"arraybar\")\n            const isColorChange = i % 3 !== 1;\n            const element = animations[i]\n            if(isColorChange){\n                if(element[0] === 4){\n                    const [,barOneIdx,barTwoIdx] = animations[i]\n                    const barOneStyle = arrayBars[barOneIdx].style\n                    const barTwoStyle = arrayBars[barTwoIdx].style\n                    const color =  i % 3 === 0 ? COMPARING_COLOR : PRIMARY_COLOR\n                    setTimeout(()=>{\n                        barOneStyle.backgroundColor = color\n                        barTwoStyle.backgroundColor = color\n                    }, i*ANIMATION_SPEED_MS)\n                }\n                if(element[0]  === 3){\n                    const [,barOneIdx,barTwoIdx] = animations[i]\n                    const barOneStyle = arrayBars[barOneIdx].style\n                    const barTwoStyle = arrayBars[barTwoIdx].style\n                    setTimeout(()=>{\n                        barOneStyle.backgroundColor = FINAL_COLOR\n                        barTwoStyle.backgroundColor = FINAL_COLOR\n                    }, i*ANIMATION_SPEED_MS)\n                }\n                else if(element[0] === 2){\n                    setTimeout(()=>{\n                        const [,barOneIdx, barTwoIdx] = animations[i]\n                        const barTwoStyle = arrayBars[barTwoIdx].style\n                        const barOneStyle = arrayBars[barOneIdx].style\n                        barOneStyle.backgroundColor = FINAL_COLOR\n                        barTwoStyle.backgroundColor = PRIMARY_COLOR\n                        },i*ANIMATION_SPEED_MS)\n                }\n                else if(element[0] === 0){\n                    const [,barOneIdx,barTwoIdx] = animations[i]\n    \n    \n                    const barOneStyle = arrayBars[barOneIdx].style\n                    const barTwoStyle = arrayBars[barTwoIdx].style\n                    const color =  i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR\n                    setTimeout(()=>{\n                        barOneStyle.backgroundColor = color\n                        barTwoStyle.backgroundColor = color\n                    }, i*ANIMATION_SPEED_MS)\n                }\n               \n                \n            }\n            else if(element[0] === 1){\n                setTimeout(() =>{\n                    const [,barOneIdx, barTwoIdx] = animations[i]\n                    const barOneStyle = arrayBars[barOneIdx].style\n                    const barTwoStyle = arrayBars[barTwoIdx].style\n                    let temp = barOneStyle.height\n                    barOneStyle.height = barTwoStyle.height\n                    barTwoStyle.height = temp\n\n                },i*ANIMATION_SPEED_MS)\n            }\n        }\n    }\n    \nexport default quickSortAnimation","import { selectionSort } from \"../SortingAlgorithms/selectionSort\";\nconst temp = (array,ANIMATION_SPEED_MS) => {\n  const animations = selectionSort(array);\n  // eslint-disable-next-line\n  for (let i=0; i < animations.length; i++) {\n    const arrayBars = document.getElementsByClassName(\"arraybar\");\n    const element = animations[i];\n    const isColorChange = i % 3 !== 1;\n    if (isColorChange) {\n      if (element[0] === 0) {\n        const [, barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const colorOne = i % 3 === 0 ? \"red\" : \"green\";\n        const colorTwo = i % 3 === 0 ? \"red\" : \"turquoise\";\n        setTimeout(() => {\n          barOneStyle.backgroundColor = colorOne;\n          barTwoStyle.backgroundColor = colorTwo;\n        }, i * ANIMATION_SPEED_MS);\n      }\n      \n      else if(element[0] === 3){\n        const [, barOneIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const color = \"yellow\"\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n    }\n\n    else if (element[0] === 2) {\n            const [, barOneIdx, barTwoIdx] = animations[i];\n            const barOneStyle = arrayBars[barOneIdx].style;\n            const barTwoStyle = arrayBars[barTwoIdx].style;\n            const colorOne = i % 3 === 0 ? \"yellow\" : \"purple\";\n            const colorTwo = i % 3 === 0 ? \"yellow\" : \"turquoise\"\n            let barThreeStyle;\n            if(i === (animations.length -1)){\n                const barThreeIdx = barTwoIdx + 1\n                barThreeStyle = arrayBars[barThreeIdx].style\n            }\n\n            setTimeout(() => {\n              barOneStyle.backgroundColor = colorOne;\n              barTwoStyle.backgroundColor = colorTwo;\n              if(i === (animations.length -1)) barThreeStyle.backgroundColor = \"purple\"\n            }, i * ANIMATION_SPEED_MS);\n    }\n    else if (element[0] === -1) {\n        const [, barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const colorOne = \"green\"\n        const colorTwo = \"turquoise\"\n        setTimeout(() => {\n          barOneStyle.backgroundColor = colorTwo;\n          barTwoStyle.backgroundColor = colorOne;\n        }, i * ANIMATION_SPEED_MS);\n    }\n    else if (element[0] === -2) {\n        const [, barOneIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const colorOne = \"purple\"\n        setTimeout(() => {\n          barOneStyle.backgroundColor = colorOne;\n        }, i * ANIMATION_SPEED_MS);\n    }\n    }\n    else{\n       if(element[0] === 1){\n           const [,barOneIdx,barTwoIdx] = animations[i]\n           const barOneStyle = arrayBars[barOneIdx].style\n           const barTwoStyle = arrayBars[barTwoIdx].style\n           setTimeout(() =>{\n                let temp = barOneStyle.height\n                barOneStyle.height = barTwoStyle.height\n                barTwoStyle.height = temp\n           }, i* ANIMATION_SPEED_MS)\n       }\n        \n    }\n}\n\n};\n\nexport default temp;\n","export function selectionSort(array){\n    let animations = [];\n    console.log(array)\n    let i = 0;\n    for(; i<array.length-1; i++){\n        let minIdx = i;\n        animations.push([3,i])\n        animations.push([])\n        animations.push([])\n        for(let j=i+1;j<array.length; j++){\n            animations.push([0,j,minIdx]);\n            if(array[j]<array[minIdx]){\n                animations.push([4,minIdx,j]);\n                animations.push([-1,minIdx,j]);\n                minIdx = j;\n            }\n            else{\n                animations.push([])\n                animations.push([0,minIdx,j]);\n            }\n        }\n        animations.push([2,i,minIdx]);\n\n\n        let temp = array[i];\n        array[i] = array[minIdx];\n        array[minIdx] = temp;\n        animations.push([1,i,minIdx]);\n        if(i === minIdx){\n            animations.push([-2,i]);\n        }\n        else{\n            animations.push([2,i,minIdx]);\n        }\n    }\n    animations.push([-2,array.length - 1]);\n    return animations;\n}\n\n","import { insertionSort } from \"../SortingAlgorithms/insertionSort\";\n\nconst insertionSortAnimation = (array,ANIMATION_SPEED_MS) => {\n  const animations = insertionSort(array);\n  \n  let keyHeight = 0;// eslint-disable-next-line\n  for (let i = 0; i < animations.length; i++) {\n    const arrayBars = document.getElementsByClassName(\"arraybar\");\n    const element = animations[i];\n    const isColorChange = i % 3 !== 1;\n    if (isColorChange) {\n      if (element[0] === 4) {\n        const [, barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? \"red\" : \"turquoise\";\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else if (element[0] === -4) {\n        const [, barOneIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const color = i % 3 === 0 ? \"yellow\" : \"turquoise\";\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else if (element[0] === -5) {\n        const [, , x] = animations[i];\n        setTimeout(() => {\n          for (let k = 0; k <= x; k++) {\n            const barStyle = arrayBars[k].style;\n            barStyle.backgroundColor = \"purple\";\n          }\n        }, i * ANIMATION_SPEED_MS);\n      }\n    } else {\n      if (element[0] === 3) {\n        const [, barIdx] = animations[i];\n        const barStyle = arrayBars[barIdx].style;\n        setTimeout(() => {\n          keyHeight = barStyle.height;// eslint-disable-next-line\n        }, i * ANIMATION_SPEED_MS);\n      } else if (element[0] === 1) {\n        const [, barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        setTimeout(() => {\n          barOneStyle.height = barTwoStyle.height;\n        }, i * ANIMATION_SPEED_MS);\n      } else if (element[0] === -1) {\n        const [, barOneIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        setTimeout(() => {\n          barOneStyle.height = keyHeight;// eslint-disable-next-line\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n};\n\nexport default insertionSortAnimation;\n","\nexport function insertionSort(array){\n    let i, key, j;\n    const animations = []\n    for (i = 1; i < array.length; i++)\n    {\n        key = array[i];\n        j = i - 1;\n        animations.push([])\n        animations.push([3,i])\n        animations.push([])\n \n        /* Move elements of array[0..i-1], that are\n        greater than key, to one position ahead\n        of their current position */\n        while (j >= 0 && array[j] > key)\n        {\n            animations.push([4,j+1,j])\n            animations.push([1,j+1,j])\n            array[j + 1] = array[j];\n            animations.push([4,j+1,j])\n            j = j - 1;\n        }\n        animations.push([-4,j+1,i])\n        animations.push([-1,j+1,i])\n        array[j + 1] = key;\n        animations.push([-5,j+1,i])\n\n    }\n    return animations\n}","export function mergeSort(array){\n    const animations = []\n    if(array.length <= 1) return array;\n    const auxillaryArray = []\n    for(let i=0; i<array.length; i++) auxillaryArray.push(array[i])\n    mergeSortHelper(array,0, array.length-1, auxillaryArray,animations)\n    return animations;\n}\n\nfunction mergeSortHelper(\n    mainArray,\n    startIdx,\n    endIdx,\n    auxillaryArray,\n    animations\n){\n    if(startIdx === endIdx) return;\n    const middleIdx = Math.floor((startIdx + endIdx)/2)\n    mergeSortHelper(auxillaryArray,startIdx,middleIdx,mainArray,animations)\n    mergeSortHelper(auxillaryArray,middleIdx+1,endIdx,mainArray,animations)\n    doMerge(mainArray, startIdx,middleIdx, endIdx,auxillaryArray,animations)\n}\n\nfunction doMerge(\n    mainArray,\n    startIdx,\n    middleIdx,\n    endIdx,\n    auxillaryArray,\n    animations\n){\n    let k = startIdx\n    let i = startIdx\n    let j = middleIdx + 1\n    while(i <= middleIdx && j<= endIdx){\n        animations.push([i,j])\n        if(auxillaryArray[i] <= auxillaryArray[j]){\n            animations.push([k,auxillaryArray[i]])\n            animations.push([i,j])\n            mainArray[k++] = auxillaryArray[i++]\n        }else{\n            animations.push([k,auxillaryArray[j]])\n            animations.push([i,j])\n            mainArray[k++] = auxillaryArray[j++]\n        }\n    }\n\n    while( i <= middleIdx){\n        animations.push([i,i])\n        animations.push([k,auxillaryArray[i]])\n        animations.push([i,i])\n\n        mainArray[k++] = auxillaryArray[i++]\n    }\n\n    while(j<= endIdx){\n        animations.push([j,j])\n        animations.push([k, auxillaryArray[j]])\n        animations.push([j,j])\n\n        mainArray[k++] = auxillaryArray[j++]\n    }\n\n}","import { mergeSort } from \"../SortingAlgorithms/mergeSort\";\n\nconst SECONDARY_COLOR = \"red\"\nconst mergeSortAnimation = (array,ANIMATION_SPEED_MS) =>{\n    const animations = mergeSort(array);\n\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName(\"arraybar\");\n      const isColorChange = i % 3 !== 1;\n      if (isColorChange) {\n        const barIdx = animations[i];\n        const barOneIdx = barIdx[0];\n        const barTwoIdx = barIdx[1];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? SECONDARY_COLOR : \"turquoise\";\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n      if(i == animations.length - 1){\n        setTimeout(()=>{\n          const allBars = document.querySelectorAll(\".arraybar\");\n        for (let i = 0; i < allBars.length; i++) {\n          const barStyle = allBars[i].style;\n          barStyle.backgroundColor = \"purple\";\n        };  \n        },i*ANIMATION_SPEED_MS)\n        \n      }\n    }\n    //return animations.length*ANIMATION_SPEED_MS;\n    \n}\n\nexport default mergeSortAnimation","import React from \"react\";\n// import \"./component.css\"\nconst BubbleSortComponent = () => {\n  return (\n    <div className=\"main-container\">\n      <div\n        className=\"unsorted\"\n        style={{\n          backgroundColor: \"turquoise\",\n          width: 100,\n          textAlign: \"center\",\n          fontWeight : \"bold\",\n          marginTop : 5,\n          marginBottom : 3,\n        }}\n      >\n        unsorted\n      </div>\n      <div\n        className=\"comparing\"\n        style={{\n          backgroundColor: \"red\",\n          width: 100,\n          textAlign: \"center\",\n          color : \"#ccc\",\n          marginBottom : 3,\n          fontWeight : \"bold\"\n        }}\n      >\n        comparing\n      </div>\n\n     \n    </div>\n  );\n};\n\nexport default BubbleSortComponent;\n","import React from \"react\";\n// import \"./component.css\"\nconst MergeSortComponent = () => {\n  return (\n    <div className=\"main-container\">\n      <div\n        className=\"swaping\"\n        style={{\n          backgroundColor: \"yellow\",\n          width: 100,\n          textAlign: \"center\",\n          marginBottom : 3,\n          marginTop : 5,\n          fontWeight : \"bold\"\n        }}\n      >\n        swaping\n      </div>\n      <div\n        className=\"sorted\"\n        style={{\n          backgroundColor: \"purple\",\n          width: 100,\n          textAlign: \"center\",\n          color : \"#ccc\",\n          marginBottom : 3,\n          fontWeight : \"bold\"\n        }}\n      >\n        sorted\n      </div>\n    </div>\n  );\n};\n\nexport default MergeSortComponent;\n","import React, { useState, useEffect } from \"react\";\nimport Slider from \"@material-ui/core/Slider\";\nimport Typography from \"@material-ui/core/Typography\";\nimport { makeStyles } from \"@material-ui/core/styles\";\n\nimport \"./SortingVisualizer.css\";\nimport bubbleSortAnimation from \"./SortingAnimations/bubbleSortAnimation\";\nimport quickSortAnimation from \"./SortingAnimations/quickSortAnimation\";\nimport selectionSortAnimation from \"./SortingAnimations/selectionSortAnimation\";\nimport insertionSortAnimation from \"./SortingAnimations/insertionSortAnimation\";\nimport mergeSortAnimation from \"./SortingAnimations/mergeSortAnimation\";\nimport BubbleSortComponent from \"./components/bubbleSortComponent\";\nimport MergeSortComponent from \"./components/mergeSortComponent\";\n\nconst useStyles = makeStyles({\n  root: {\n    width: 165,\n    position : \"relative\",\n    bottom : 8,\n  },\n  label:{\n    fontSize : 13,\n    position : \"relative\",\n    top : 2,\n    color : \"white\",\n    fontWeight : \"bold\"\n  }\n});\nconst PRIMARY_COLOR = \"turquoise\";\nconst SortingVisualizer = () => {\n  const classes = useStyles();\n  const [array, setArray] = useState([]);\n  const [value, setValue] = useState(30);\n  const [ANIMATION_SPEED_MS, setANIMATION_SPEED_MS] = useState(2);\n  const [currentSort, setCurrentSort] = useState(\"Algorithms\");\n\n  //Run this during first render\n  useEffect(() => {\n    const { _height } = getWindowDimensions();\n\n    const _resetArray = () => {\n      const temp = [];\n    for (let i = 0; i < value; i++) {\n      temp.push(randomIntFromInterval(5, _height - _height / 4));\n    }\n    setArray(temp);\n    const allBars = document.querySelectorAll(\".arraybar\");\n    for (let i = 0; i < allBars.length; i++) {\n      const barStyle = allBars[i].style;\n      barStyle.backgroundColor = \"turquoise\";\n    };\n  }\n    _resetArray();\n  }, []);\n\n  //Getting dimensions of window\n  function getWindowDimensions() {\n    const { innerWidth: _width, innerHeight: _height } = window;\n    return {\n      _width,\n      _height,\n    };\n  }\n\n\n  //Calling getWindowDimensions method(destructering)\n  const { _height, _width } = getWindowDimensions();\n  const newWidth = _width - _width / 8;\n\n  //creating new random array\n  const resetArray = (NO_OF_ARRAY_BAR) => {\n    console.log(window.innerHeight, window.innerWidth)\n    \n    const temp = [];\n    for (let i = 0; i < NO_OF_ARRAY_BAR; i++) {\n      temp.push(randomIntFromInterval(5, _height - _height / 4));\n    }\n    setArray(temp);\n    const allBars = document.querySelectorAll(\".arraybar\");\n    for (let i = 0; i < allBars.length; i++) {\n      const barStyle = allBars[i].style;\n      barStyle.backgroundColor = \"turquoise\";\n    }\n  };\n\n  //Creating random Integer\n  const randomIntFromInterval = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  };\n\n  //BubbleSort animation\n  const _bubbleSort = () => {\n    bubbleSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n\n  //MergeSort Animation\n  const _mergeSort = () => {\n    mergeSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n\n  //QuickSort Animation\n  const _quickSort = () => {\n    quickSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n\n  const _selectionSort = () => {\n\n    selectionSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n  const _insertionSort = () => {\n    insertionSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n  const handleChange = (event, value) => {\n    setValue(value);\n    resetArray(value);\n  };\n  const handleChangeSpeed = (event, value) => {\n    setANIMATION_SPEED_MS(event.target.value);\n  };\n  const handleChangeCurrentSort = (event) => {\n    setCurrentSort(event.target.value);\n  };\n  const visualizeAlgorithm = () => {\n    switch (currentSort) {\n      case \"bubbleSort\":\n       _bubbleSort();\n        break;\n      case \"insertionSort\":\n        _insertionSort();\n        break;\n      case \"quickSort\":\n        _quickSort();\n        break;\n      case \"mergeSort\":\n        _mergeSort();\n        break;\n      case \"selectionSort\":\n        _selectionSort();\n        break;\n      default:\n        _bubbleSort();\n        break;\n    }\n  };\n\n  return (\n    <div className=\"array-container\">\n      <div className=\"infoBar-container\">\n        <div style={{ paddingTop : 10}}>\n          <div className=\"box\" style={{ display : \"inline\",position: \"relative\", bottom : 10}}>\n          <select onChange={handleChangeSpeed}>\n            <option value=\"2\">TOO FAST</option>\n            <option value=\"20\">FAST</option>\n            <option value=\"100\">SLOW</option>\n            <option value=\"2000\">TOO SLOW</option>\n          </select>\n          </div>\n        </div>\n        <div className=\"slider-container\">\n        {/* <Typography className={classes.label} gutterBottom>\n              SPEED\n          </Typography>          \n          <Slider\n            className={classes.root}\n            value={ANIMATION_SPEED_MS}\n            min={2}\n            max={230}\n            onChange={handleChangeSpeed}\n            aria-labelledby=\"continuous-slider\"\n          /> */}\n\n          <Typography className={classes.label}>\n            BARS\n          </Typography>\n          <Slider\n            className={classes.root}\n            value={value}\n            min={10}\n            max={newWidth / 5 - 20}\n            onChange={handleChange}\n            aria-labelledby=\"continuous-slider\"\n          />\n        </div>\n        <div className=\"button-container\">\n          {/* Button 3 */}\n          <button  style={{backgroundColor : \"#228b22\", color : \"white\", borderColor : \"#228b22\",padding : 8,}} onClick={() => resetArray(value)}>NEW ARRAY</button>\n            <div className=\"box\" style={{ display : \"inline\",}}>\n          <select onChange={handleChangeCurrentSort} >\n            <option selected value=\"bubbleSort\">\n              Bubble Sort\n            </option>\n            <option value=\"insertionSort\">Insertion Sort</option>\n            <option value=\"quickSort\">Quick Sort</option>\n            <option value=\"mergeSort\">Merge Sort</option>\n            <option value=\"selectionSort\">SelectionSort</option>\n          </select>\n          </div>\n          <button  style={{backgroundColor : \"#228b22\", color : \"white\", borderColor : \"#228b22\",padding : 8,}} onClick={visualizeAlgorithm}>VISUALIZE</button>\n        </div>\n        <div className=\"grap-container\">{/* Graph or Index */}\n        <div>\n        <BubbleSortComponent />\n        </div>\n       \n        </div>\n        <div className=\"temp\">\n        <MergeSortComponent />\n        </div>\n      </div>\n\n      {/* Array Bars */}\n      <div className=\"arraybar-container\">\n        {array.map((_value, index) => (\n          <div\n            className=\"arraybar\"\n            key={index}\n            style={{\n              height: `${_value}px`,\n              width: newWidth / value - 2,\n              paddingLeft: 0,\n              backgroundColor: PRIMARY_COLOR,\n            }}\n          ></div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default SortingVisualizer;\n","import React from \"react\";\nimport \"./navbar.css\"\nimport { Link } from \"react-router-dom\";\n\nconst NavBar = () => {\n  const logo =\n    window.innerWidth > 600 ? \"Algorithm Visualizer\" : \"AlgoVisualizer\";\n\n  return (\n    <nav className=\"navbar navbar-expand navbar-dark bg-dark\">\n      <a className=\"navbar-brand h1 mb-0\">{logo}</a>\n      {/*  <button\n        class=\"navbar-toggler\"\n        type=\"button\"\n        data-toggle=\"collapse\"\n        data-target=\"#navbarSupportedContent\"\n        aria-controls=\"navbarSupportedContent\"\n        aria-expanded=\"false\"\n        aria-label=\"Toggle navigation\" \n        \n        >\n        <span class=\"navbar-toggler-icon\"></span> \n      </button> */}\n\n      <div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n        <ul class=\"navbar-nav mr-auto\" >\n          <li class=\"nav-item active\">\n            <Link class=\"nav-link\" to=\"/\"> Sorting\n              {/* Home <span class=\"sr-only\">(current)</span> */}\n            </Link>\n          </li>\n          <li class=\"nav-item\">\n            <Link  class=\"nav-link\" to=\"/pathFinding\">\n              PathFinding\n            </Link>\n          </li>\n        </ul>\n      </div>\n    </nav>\n  );\n};\n\nexport default NavBar;\n","import \"./App.css\";\nimport { HashRouter as Router, Switch, Route } from \"react-router-dom\";\nimport PathFindingVisualizerScreen from \"./Screens/PathFindingVisualizerScreen\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\nimport NavBar from \"./navbar/navbar.jsx\";\n\nfunction App() {\n  return (\n    <Router>\n      <NavBar />\n      <Switch>\n      <Route exact path=\"/\" component={SortingVisualizer} />\n      <Route  path=\"/pathFinding\" component={PathFindingVisualizerScreen} />\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n// import { HashRouter } from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}