{"version":3,"sources":["PathFindingVisualizer/mazeAlgorithms/recursizeDivision.js","PathFindingVisualizer/mazeAlgorithms/verticalMaze.js","PathFindingVisualizer/mazeAlgorithms/horizontalMaze.js","PathFindingVisualizer/node/node.jsx","PathFindingVisualizer/algorithm/dijkstra.js","PathFindingVisualizer/algorithm/astar.js","PathFindingVisualizer/algorithm/breadthFirstSearch.js","PathFindingVisualizer/algorithm/depthFirstSearch.js","PathFindingVisualizer/algorithm/greedyBestFirstSearch.js","PathFindingVisualizer/algorithm/bidirectionalGreedySearch.js","PathFindingVisualizer/PathFindingVisualizer.jsx","PathFindingVisualizer/mazeAlgorithms/randomMaze.js","Screens/PathFindingVisualizerScreen.js","SortingVisualizer/SortingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["walls","Node","props","cellHeight","row","col","isStart","isFinish","isWall","isVisited","isShortest","width","height","numRows","numColumns","onDragStart","onDragOver","onDrop","extraClass","isPlace","cellWidth","Math","floor","id","draggable","event","className","style","e","dijkstra","grid","startNode","finishNode","distance","unvisitedNodes","nodes","node","push","getNodes","visitedNodesInOrder","length","sort","a","b","closestNode","shift","Infinity","updateUnvisitedNeighbours","unvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","unvisitedNeighbour","previousNode","getNeighbours","neighbourNotInUnvisitedNodes","manhattenDistance","abs","isNeighbour","closestNodeStart","closestNodeFinish","rowStart","colStart","rowFinish","colFinish","nodeA","nodeB","recursiveDivisionMaze","vertical","range","horizontal","getRecursiveWalls","len","result","i","dir","num","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","random","isStartFinish","tempWalls","temp","splice","generateRandomNumber","wall","verticalMaze","choice","getVerticalWalls","horizontalMaze","getHorizontalWalls","initialNum","getInitialNum","window","innerWidth","innerHeight","initialNumRows","initialNumColumns","startFinishNode","randomNums","x","y","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","getRandomNums","getStartFinishNode","getNewGridWithMaze","newGrid","newNode","getVisitedNodesInOrder","visitedNodesInOrderStart","visitedNodesInOrderFinish","n","undefined","randomNums1","randomNums2","PathFindingVisualizer","useState","setGrid","setWidth","setHeight","speed","visualizingAlgorithm","setVisualizingAlgorithm","generatingMaze","setGeneratingMaze","mazeSpeed","currAlgo","setCurrAlgo","maze","setMaze","dragStartData","setDragStartData","dragEndData","setDragEndData","sNode","setSNode","fNode","setFNode","isTarget","setIsTarget","useEffect","addEventListener","updateDimensions","getInitialGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","updateNodesForRender","document","getElementById","animateAlgorithm","visualizeAStar","totalDistance","unshift","astar","currentNode","getNodesInShortestPathOrderAstar","visualizeBFS","breadthFirstSearch","getNodesInShortestPathOrderBFS","visualizeDFS","depthFirstSearch","getNodesInShortestPathOrderDFS","visualizeGreedyBFS","greedyBFS","getNodesInShortestPathOrderGreedyBFS","visualizeBidirectionalGreedySearch","unvisitedNodesStart","unvisitedNodesFinish","bidirectionalGreedySearch","isShortedPath","animateBidirectionalAlgorithm","getNodesInShortestPathOrderBidirectionalGreedySearch","clearGrid","animateMaze","generateRandomMaze","randomMaze","currentRow","createNode","onChange","target","value","handleAlgoChange","onClick","getNodesInShortestPathOrderDijkstra","backgroundColor","color","borderColor","padding","console","log","handleMazeChange","type","map","rowId","nodeId","preventDefault","handleDragOver","handleDragStart","handleDrop","PathFindingVisualizerScreen","makeStyles","root","position","bottom","label","fontSize","top","fontWeight","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.a758f6d0.chunk.js","sourcesContent":["let walls;\nexport function recursiveDivisionMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode) {\n  if (vertical.length < 2 || horizontal.length < 2) {\n    return;\n  }\n  let dir;\n  let num;\n  if (vertical.length > horizontal.length) {\n    dir = 0;\n    num = generateOddRandomNumber(vertical);\n  }\n  if (vertical.length <= horizontal.length) {\n    dir = 1;\n    num = generateOddRandomNumber(horizontal);\n  }\n\n  if (dir === 0) {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical.slice(0, vertical.indexOf(num)),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical.slice(vertical.indexOf(num) + 1),\n      horizontal,\n      grid,\n      startNode,\n      finishNode\n    );\n  } else {\n    addWall(dir, num, vertical, horizontal, startNode, finishNode);\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(0, horizontal.indexOf(num)),\n      grid,\n      startNode,\n      finishNode\n    );\n    getRecursiveWalls(\n      vertical,\n      horizontal.slice(horizontal.indexOf(num) + 1),\n      grid,\n      startNode,\n      finishNode\n    );\n  }\n}\n\nfunction generateOddRandomNumber(array) {\n  let max = array.length - 1;\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 === 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return array[randomNum];\n}\n\n//dir === 0 => Horizontal\n//dir === 1 => Vertical\n\nfunction addWall(dir, num, vertical, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  if (dir === 0) {\n    if (horizontal.length === 2) return;\n    for (let temp of horizontal) {\n      if (\n        (temp === startNode.row && num === startNode.col) ||\n        (temp === finishNode.row && num === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([temp, num]);\n    }\n  } else {\n    if (vertical.length === 2) return;\n    for (let temp of vertical) {\n      if (\n        (num === startNode.row && temp === startNode.col) ||\n        (num === finishNode.row && temp === finishNode.col)\n      ) {\n        isStartFinish = true;\n        continue;\n      }\n      tempWalls.push([num, temp]);\n    }\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}\n\nfunction generateRandomNumber(max) {\n  let randomNum =\n    Math.floor(Math.random() * (max / 2)) +\n    Math.floor(Math.random() * (max / 2));\n  if (randomNum % 2 !== 0) {\n    if (randomNum === max) {\n      randomNum -= 1;\n    } else {\n      randomNum += 1;\n    }\n  }\n  return randomNum;\n}","let walls;\nexport function verticalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getVerticalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getVerticalWalls(vertical, horizontal, startNode, finishNode) {\n  if (vertical.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of vertical) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, horizontal, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, horizontal, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of horizontal) {\n    if (\n      (temp === startNode.row && num === startNode.col) ||\n      (temp === finishNode.row && num === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([temp, num]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","let walls;\nexport function horizontalMaze(grid, startNode, finishNode) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n  let vertical = range(grid[0].length);\n  let horizontal = range(grid.length);\n  walls = [];\n  getHorizontalWalls(vertical, horizontal, startNode, finishNode);\n  return walls;\n}\n\nfunction range(len) {\n  let result = [];\n  for (let i = 0; i < len; i++) {\n    result.push(i);\n  }\n  return result;\n}\n\nfunction getHorizontalWalls(vertical, horizontal, startNode, finishNode) {\n  if (horizontal.length < 2) {\n    return;\n  }\n\n  let choice = Math.floor(Math.random() * 2);\n  for (let num of horizontal) {\n    if (choice === 0 && num % 2 !== 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n    if (choice === 1 && num % 2 === 0) {\n      addWall(num, vertical, startNode, finishNode);\n    }\n  }\n}\n\nfunction addWall(num, vertical, startNode, finishNode) {\n  let isStartFinish = false;\n  let tempWalls = [];\n  for (let temp of vertical) {\n    if (\n      (num === startNode.row && temp === startNode.col) ||\n      (num === finishNode.row && temp === finishNode.col)\n    ) {\n      isStartFinish = true;\n      continue;\n    }\n    tempWalls.push([num, temp]);\n  }\n  if (!isStartFinish) {\n    tempWalls.splice(Math.floor(Math.random() * tempWalls.length), 1);\n  }\n  for (let wall of tempWalls) {\n    walls.push(wall);\n  }\n}","import React from \"react\";\nimport \"./node.css\";\n\nconst Node = (props) => {\n  const {\n    row,\n    col,\n    isStart,\n    isFinish,\n    isWall,\n    isVisited,\n    isShortest,\n    width,\n    height,\n    numRows,\n    numColumns,\n    onDragStart,\n    onDragOver,\n    onDrop\n  } = props;\n\n  const extraClass = isStart\n    ? \"node node-start\"\n    : isFinish\n    ? \"node node-finish\"\n    : isWall\n    ? \"node-wall\"\n    : isShortest\n    ? \"node node-shortest-path\"\n    : isVisited\n    ? \"node node-visited\"\n    : \"node\";\n\n\n\n    const isPlace = isStart || isFinish;\n  const block = () => {\n    if (isPlace) {\n      return (\n        <div\n          id={`node-${row}-${col}`}\n          draggable\n          onDragStart={(event)=>onDragStart(event)}\n          className={`${extraClass}`}\n          style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\n        ></div>\n      );\n    } else {\n      return (\n        <div\n          id={`node-${row}-${col}`}\n          onDragOver={(e)=>onDragOver(e)}\n          onDrop={()=>onDrop()}\n          className={`node ${extraClass}`}\n          style={{ \"--width\": `${cellWidth}px`, \"--height\": `${cellHeight}px` }}\n          \n        ></div>\n      )\n    }\n  }\n\n\n    let cellWidth = Math.floor((width - 15) / numColumns);\n    let cellHeight;\n    if (width > 1500) {\n      cellHeight = Math.floor((height - 70) / numRows);\n    } else if (width > 1000) {\n      cellHeight = Math.floor((height - 70) / numRows);\n    } else if (width > 500) {\n      cellHeight = Math.floor((height - 60) / numRows);\n    } else if (width > 0) {\n      cellHeight = Math.floor((height - 50) / numRows);\n    }\n\n    return (\n        <>\n        {block()}\n        </>\n         \n       \n      );\n};\n\nexport default Node;\n","export function dijkstra(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    startNode.distance = 0;\n    let unvisitedNodes = getNodes(grid);\n    let visitedNodesInOrder = [];\n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.distance - b.distance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      updateUnvisitedNeighbours(closestNode, grid);\n    }\n  }\n  \n  function getNodes(grid) {\n    let nodes = [];\n    for (let row of grid) {\n      for (let node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  function updateUnvisitedNeighbours(node, grid) {\n    let unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\n    for (let unvisitedNeighbour of unvisitedNeighbours) {\n      unvisitedNeighbour.distance = node.distance + 1;\n      unvisitedNeighbour.previousNode = node;\n    }\n  }\n  \n  function getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours\n      .filter((neighbour) => !neighbour.isWall)\n      .filter((neighbour) => !neighbour.isVisited);\n  }\n  \n  export function getNodesInShortestPathOrderDijkstra(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function astar(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = []; //open list\n    let visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    unvisitedNodes.push(startNode);\n  \n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode === finishNode) return visitedNodesInOrder;\n  \n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n  \n      let neighbours = getNeighbours(closestNode, grid);\n      for (let neighbour of neighbours) {\n        let distance = closestNode.distance + 1;\n        //f(n) = g(n) + h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n          unvisitedNodes.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance =\n            distance + manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance =\n            distance + manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  function manhattenDistance(node, finishNode) {\n    let x = Math.abs(node.row - finishNode.row);\n    let y = Math.abs(node.col - finishNode.col);\n    return x + y;\n  }\n  \n  export function getNodesInShortestPathOrderAstar(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function breadthFirstSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = [];\n    let visitedNodesInOrder = [];\n    unvisitedNodes.push(startNode);\n    while (unvisitedNodes.length !== 0) {\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      visitedNodesInOrder.push(closestNode);\n      closestNode.isVisited = true;\n      let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n      for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.previousNode = closestNode;\n        if (neighbourNotInUnvisitedNodes(unvisitedNeighbour, unvisitedNodes)) {\n          unvisitedNodes.push(unvisitedNeighbour);\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }\n  ","export function depthFirstSearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = [];\n    let visitedNodesInOrder = [];\n    unvisitedNodes.push(startNode);\n    while (unvisitedNodes.length !== 0) {\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode.isWall) continue;\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      visitedNodesInOrder.push(closestNode);\n      closestNode.isVisited = true;\n      let unvisitedNeighbours = getUnvisitedNeighbours(closestNode, grid);\n      for (let unvisitedNeighbour of unvisitedNeighbours) {\n        unvisitedNeighbour.previousNode = closestNode;\n        unvisitedNodes.unshift(unvisitedNeighbour);\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getUnvisitedNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    return neighbours.filter((neighbour) => !neighbour.isVisited);\n  }\n  \n  export function getNodesInShortestPathOrderDFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","export function greedyBFS(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodes = []; //open list\n    let visitedNodesInOrder = []; //closed list\n    startNode.distance = 0;\n    unvisitedNodes.push(startNode);\n  \n    while (unvisitedNodes.length !== 0) {\n      unvisitedNodes.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNode = unvisitedNodes.shift();\n      if (closestNode === finishNode) return visitedNodesInOrder;\n  \n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n  \n      let neighbours = getNeighbours(closestNode, grid);\n      for (let neighbour of neighbours) {\n        let distance = closestNode.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes)) {\n          unvisitedNodes.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNode;\n        }\n      }\n    }\n    return visitedNodesInOrder;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(node, finishNode) {\n    let x = Math.abs(node.row - finishNode.row);\n    let y = Math.abs(node.col - finishNode.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderGreedyBFS(finishNode) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","export function bidirectionalGreedySearch(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let unvisitedNodesStart = [];\n    let visitedNodesInOrderStart = [];\n    let unvisitedNodesFinish = [];\n    let visitedNodesInOrderFinish = [];\n    startNode.distance = 0;\n    finishNode.distance = 0;\n    unvisitedNodesStart.push(startNode);\n    unvisitedNodesFinish.push(finishNode);\n  \n    while (\n      unvisitedNodesStart.length !== 0 &&\n      unvisitedNodesFinish.length !== 0\n    ) {\n      unvisitedNodesStart.sort((a, b) => a.totalDistance - b.totalDistance);\n      unvisitedNodesFinish.sort((a, b) => a.totalDistance - b.totalDistance);\n      let closestNodeStart = unvisitedNodesStart.shift();\n      let closestNodeFinish = unvisitedNodesFinish.shift();\n  \n      closestNodeStart.isVisited = true;\n      closestNodeFinish.isVisited = true;\n      visitedNodesInOrderStart.push(closestNodeStart);\n      visitedNodesInOrderFinish.push(closestNodeFinish);\n      if (isNeighbour(closestNodeStart, closestNodeFinish)) {\n        return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n      }\n  \n      //Start side search\n      let neighbours = getNeighbours(closestNodeStart, grid);\n      for (let neighbour of neighbours) {\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n          visitedNodesInOrderStart.push(closestNodeStart);\n          visitedNodesInOrderFinish.push(neighbour);\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        }\n        let distance = closestNodeStart.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n          unvisitedNodesStart.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNodeStart;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, finishNode);\n          neighbour.previousNode = closestNodeStart;\n        }\n      }\n  \n      //Finish side search\n      neighbours = getNeighbours(closestNodeFinish, grid);\n      for (let neighbour of neighbours) {\n        if (!neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesStart)) {\n          visitedNodesInOrderStart.push(closestNodeFinish);\n          visitedNodesInOrderStart.push(neighbour);\n          return [visitedNodesInOrderStart, visitedNodesInOrderFinish, true];\n        }\n        let distance = closestNodeFinish.distance + 1;\n        //f(n) = h(n)\n        if (neighbourNotInUnvisitedNodes(neighbour, unvisitedNodesFinish)) {\n          unvisitedNodesFinish.unshift(neighbour);\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n          neighbour.previousNode = closestNodeFinish;\n        } else if (distance < neighbour.distance) {\n          neighbour.distance = distance;\n          neighbour.totalDistance = manhattenDistance(neighbour, startNode);\n          neighbour.previousNode = closestNodeFinish;\n        }\n      }\n    }\n    return [visitedNodesInOrderStart, visitedNodesInOrderFinish, false];\n  }\n  \n  function isNeighbour(closestNodeStart, closestNodeFinish) {\n    let rowStart = closestNodeStart.row;\n    let colStart = closestNodeStart.col;\n    let rowFinish = closestNodeFinish.row;\n    let colFinish = closestNodeFinish.col;\n    if (rowFinish === rowStart - 1 && colFinish === colStart) return true;\n    if (rowFinish === rowStart && colFinish === colStart + 1) return true;\n    if (rowFinish === rowStart + 1 && colFinish === colStart) return true;\n    if (rowFinish === rowStart && colFinish === colStart - 1) return true;\n    return false;\n  }\n  \n  function getNeighbours(node, grid) {\n    let neighbours = [];\n    let { row, col } = node;\n    if (row !== 0) neighbours.push(grid[row - 1][col]);\n    if (col !== grid[0].length - 1) neighbours.push(grid[row][col + 1]);\n    if (row !== grid.length - 1) neighbours.push(grid[row + 1][col]);\n    if (col !== 0) neighbours.push(grid[row][col - 1]);\n    return neighbours.filter(\n      (neighbour) => !neighbour.isWall && !neighbour.isVisited\n    );\n  }\n  \n  function manhattenDistance(nodeA, nodeB) {\n    let x = Math.abs(nodeA.row - nodeB.row);\n    let y = Math.abs(nodeA.col - nodeB.col);\n    return x + y;\n  }\n  \n  function neighbourNotInUnvisitedNodes(neighbour, unvisitedNodes) {\n    for (let node of unvisitedNodes) {\n      if (node.row === neighbour.row && node.col === neighbour.col) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  export function getNodesInShortestPathOrderBidirectionalGreedySearch(\n    nodeA,\n    nodeB\n  ) {\n    let nodesInShortestPathOrder = [];\n    let currentNode = nodeB;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.push(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    currentNode = nodeA;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","import React, { useState, useEffect } from \"react\";\nimport Node from \"./node/node\";\nimport \"./PathFindingVisualizer.css\";\nimport {\n  dijkstra,\n  getNodesInShortestPathOrderDijkstra,\n} from \"./algorithm/dijkstra\";\nimport { astar, getNodesInShortestPathOrderAstar } from \"./algorithm/astar\";\nimport {\n  breadthFirstSearch,\n  getNodesInShortestPathOrderBFS,\n} from \"./algorithm/breadthFirstSearch\";\n\nimport {\n  depthFirstSearch,\n  getNodesInShortestPathOrderDFS,\n} from \"./algorithm/depthFirstSearch\";\nimport {\n  greedyBFS,\n  getNodesInShortestPathOrderGreedyBFS,\n} from \"./algorithm/greedyBestFirstSearch\";\nimport {\n  bidirectionalGreedySearch,\n  getNodesInShortestPathOrderBidirectionalGreedySearch,\n} from \"./algorithm/bidirectionalGreedySearch\";\n\nimport { randomMaze } from \"./mazeAlgorithms/randomMaze\";\nimport { recursiveDivisionMaze } from \"./mazeAlgorithms/recursizeDivision\";\nimport { verticalMaze } from \"./mazeAlgorithms/verticalMaze\";\nimport { horizontalMaze } from \"./mazeAlgorithms/horizontalMaze\";\n\nconst initialNum = getInitialNum(window.innerWidth-100, window.innerHeight-100);\nconst initialNumRows = initialNum[0];\nconst initialNumColumns = initialNum[1];\n\nconst startFinishNode = getStartFinishNode(initialNumRows, initialNumColumns);\nconst startNodeRow = startFinishNode[0];\nconst startNodeCol = startFinishNode[1];\nconst finishNodeRow = startFinishNode[2];\nconst finishNodeCol = startFinishNode[3];\n\nconst PathFindingVisualizer = () => {\n  const [grid, setGrid] = useState([]);\n  const [width, setWidth] = useState(window.innerWidth);\n  const [height, setHeight] = useState(window.innerHeight);\n  const [speed, ] = useState(10);\n  const [visualizingAlgorithm, setVisualizingAlgorithm] = useState(false);\n  const [generatingMaze, setGeneratingMaze] = useState(false);\n  const [mazeSpeed, ] = useState(10);\n  const [numRows, ] = useState(initialNumRows);\n  const [numColumns, ] = useState(initialNumColumns);\n  const [currAlgo, setCurrAlgo] = useState(\"A* algorithm\");\n  const [maze, setMaze] = useState(\"Random Maze\");\n  const [dragStartData, setDragStartData] = useState([startNodeRow, startNodeCol]);\n  const [dragEndData, setDragEndData] = useState([finishNodeRow,finishNodeCol])\n  const [sNode,setSNode] = useState([startNodeRow,startNodeCol]);\n  const [fNode,setFNode] = useState([finishNodeRow,finishNodeCol])\n  const [isTarget,setIsTarget]  = useState(false)\n\n\n  useEffect(() => {\n    window.addEventListener(\"resize\", updateDimensions());\n    // eslint-disable-next-line\n    const newGrid = getInitialGrid(numRows, numColumns);// eslint-disable-next-line\n    setGrid(newGrid);\n  }, []);\n\n  const updateDimensions = () => {\n    setHeight(window.innerHeight);\n    setWidth(window.innerWidth);\n  };\n\n  const handleDragOver = (e) => {\n    e.preventDefault();\n  };\n  const handleDragStart = (event, row, col) => {\n    if(row === sNode[0] && col === sNode[1]){\n      setDragStartData([row, col]);\n    }\n    else{\n      setIsTarget(true)\n      setDragEndData([row,col]);\n    }\n  };\n\n  const handleDrop = (row, col) => {\n    const newGrid = grid;\n    const temp = newGrid[row][col];\n    if(isTarget){\n      setFNode([row,col])\n      document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\n      document.getElementById(`node-${dragEndData[0]}-${dragEndData[1]}`).className =\n        \"node\";\n        temp.isFinish = true;\n    }\n    else{\n      setSNode([row,col]);\n    document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\n    document.getElementById(`node-${dragStartData[0]}-${dragStartData[1]}`).className =\n      \"node\";\n      temp.isStart = true;\n\n    }\n    \n    setIsTarget(false);\n    newGrid[row][col] = temp;\n    setGrid(newGrid);\n  };\n\n  const animateShortestPath = (\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    if (nodesInShortestPathOrder.length === 1) {\n      setVisualizingAlgorithm(false);\n    }\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\n      if (i === nodesInShortestPathOrder.length - 1) {\n        setTimeout(() => {\n          let newGrid = updateNodesForRender(\n            grid,\n            nodesInShortestPathOrder,\n            visitedNodesInOrder\n          );\n          setGrid(newGrid);\n          setVisualizingAlgorithm(false);\n        }, i * (3 * speed));\n        return;\n      }\n      let node = nodesInShortestPathOrder[i];\n      setTimeout(() => {\n        //shortest path node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, i * (3 * speed));\n    }\n  };\n\n  const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    let newGrid = grid;\n    for (let row of newGrid) {\n      for (let node of row) {\n        let newNode = {\n          ...node,\n          isVisited: false,\n        };\n        newGrid[node.row][node.col] = newNode;\n      }\n    }\n    setGrid(newGrid);\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      let node = visitedNodesInOrder[i];\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited node\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, i * speed);\n    }\n  };\n\n  function animateBidirectionalAlgorithm(\n    visitedNodesInOrderStart,\n    visitedNodesInOrderFinish,\n    nodesInShortestPathOrder,\n    isShortedPath\n  ) {\n    let len = Math.max(\n      visitedNodesInOrderStart.length,\n      visitedNodesInOrderFinish.length\n    );\n    for (let i = 1; i <= len; i++) {\n      let nodeA = visitedNodesInOrderStart[i];\n      let nodeB = visitedNodesInOrderFinish[i];\n      if (i === visitedNodesInOrderStart.length) {\n        setTimeout(() => {\n          let visitedNodesInOrder = getVisitedNodesInOrder(\n            visitedNodesInOrderStart,\n            visitedNodesInOrderFinish\n          );\n          if (isShortedPath) {\n            animateShortestPath(nodesInShortestPathOrder, visitedNodesInOrder);\n          } else {\n            setVisualizingAlgorithm(true);\n          }\n        }, i * speed);\n        return;\n      }\n      setTimeout(() => {\n        //visited nodes\n        if (nodeA !== undefined)\n          document.getElementById(`node-${nodeA.row}-${nodeA.col}`).className =\n            \"node node-visited\";\n        if (nodeB !== undefined)\n          document.getElementById(`node-${nodeB.row}-${nodeB.col}`).className =\n            \"node node-visited\";\n      }, i * speed);\n    }\n  }\n\n  function visualizeDijkstra() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDijkstra(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  const updateNodesForRender = (\n    grid,\n    nodesInShortestPathOrder,\n    visitedNodesInOrder\n  ) => {\n    let newGrid = grid.slice();\n    for (let node of visitedNodesInOrder) {\n      if (\n        (node.row === sNode[0] && node.col === sNode[1]) ||\n        (node.row === fNode[0] && node.col === fNode[1])\n      )\n        continue;\n      let newNode = {\n        ...node,\n        isVisited: true,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n    for (let node of nodesInShortestPathOrder) {\n      if (node.row === fNode[0] && node.col === fNode[1]) {\n        return newGrid;\n      }\n      let newNode = {\n        ...node,\n        isVisited: false,\n        isShortest: true,\n      };\n      newGrid[node.row][node.col] = newNode;\n    }\n  };\n\n  function visualizeAStar() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = astar(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderAstar(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeBFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = breadthFirstSearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderBFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeDFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderDFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeGreedyBFS() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = greedyBFS(grid, startNode, finishNode);\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderGreedyBFS(finishNode);\n      animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    }, speed);\n  }\n\n  function visualizeBidirectionalGreedySearch() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setVisualizingAlgorithm(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const visitedNodesInOrder = bidirectionalGreedySearch(\n        grid,\n        startNode,\n        finishNode\n      );\n      const visitedNodesInOrderStart = visitedNodesInOrder[0];\n      const visitedNodesInOrderFinish = visitedNodesInOrder[1];\n      const isShortedPath = visitedNodesInOrder[2];\n      const nodesInShortestPathOrder =\n        getNodesInShortestPathOrderBidirectionalGreedySearch(\n          visitedNodesInOrderStart[visitedNodesInOrderStart.length - 1],\n          visitedNodesInOrderFinish[visitedNodesInOrderFinish.length - 1]\n        );\n      animateBidirectionalAlgorithm(\n        visitedNodesInOrderStart,\n        visitedNodesInOrderFinish,\n        nodesInShortestPathOrder,\n        isShortedPath\n      );\n    }, speed);\n  }\n\n  function clearGrid() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          !(\n            (row === sNode[0] && col === sNode[1]) ||\n            (row === fNode[0] && col === fNode[1])\n          )\n        ) {\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\n        }\n      }\n    }\n    const newGrid = getInitialGrid(numRows, numColumns);\n    setVisualizingAlgorithm(false);\n    setGeneratingMaze(false);\n    setGrid(newGrid);\n  }\n\n  const animateMaze = (walls) => {\n    for (let i = 0; i <= walls.length; i++) {\n      if (i === walls.length) {\n        setTimeout(() => {\n          clearGrid();\n          let newGrid = getNewGridWithMaze(grid, walls);\n          setGrid(newGrid);\n          setGeneratingMaze(false);\n        }, i * mazeSpeed);\n        return;\n      }\n      let wall = walls[i];\n      let node = grid[wall[0]][wall[1]];\n      setTimeout(() => {\n        //Walls\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-wall-animated\";\n      }, i * mazeSpeed);\n    }\n  };\n\n  function generateRandomMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = randomMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateRecursiveDivisionMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateVerticalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = verticalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  function generateHorizontalMaze() {\n    if (visualizingAlgorithm || generatingMaze) {\n      return;\n    }\n    setGeneratingMaze(true);\n    setTimeout(() => {\n      const startNode = grid[sNode[0]][sNode[1]];\n      const finishNode = grid[fNode[0]][fNode[1]];\n      const walls = horizontalMaze(grid, startNode, finishNode);\n      animateMaze(walls);\n    }, mazeSpeed);\n  }\n\n  const handleAlgoChange = (event) => {\n    setCurrAlgo(event.target.value);\n  };\n\n  const handleMazeChange = (event) => {\n    setMaze(event.target.value);\n    console.log(event.target.value);\n  };\n\n  const visualizer = () => {\n    if (currAlgo === \"Dijkstra\") visualizeDijkstra();\n    else if (currAlgo === \"A* algorithm\") visualizeAStar();\n    else if (currAlgo === \"Breadth First Search\") visualizeBFS();\n    else if (currAlgo === \"Depth First Search\") visualizeDFS();\n    else if (currAlgo === \"Greedy BFS\") visualizeGreedyBFS();\n    else if (currAlgo === \"Bidirectional Greedy Search\")\n      visualizeBidirectionalGreedySearch();\n  };\n  const generateMaze = () => {\n    if (maze === \"Random Maze\") generateRandomMaze();\n    else if (maze === \"Recursive Maze\") generateRecursiveDivisionMaze();\n    else if (maze === \"Horizontal Maze\") generateHorizontalMaze();\n    else if (maze === \"Vertical Maze\") generateVerticalMaze();\n  };\n\n\n  const getInitialGrid = (numRows, numColumns) => {\n    let grid = [];\n    for (let row = 0; row < numRows - 3; row++) {\n      let currentRow = [];\n      for (let col = 0; col < numColumns - 5; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n  \n  const createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === sNode[0] && col === sNode[1],\n      isFinish: row === fNode[0] && col === fNode[1],\n      distance: Infinity,\n      totalDistance: Infinity,\n      isVisited: false,\n      isShortest: false,\n      isWall: false,\n      previousNode: null,\n    };\n  };\n\n  return (\n    <div className=\"container-fluid\">\n      <div className=\"info-container\">\n        <div className=\"box\">\n        <select onChange={(event) => handleAlgoChange(event)}>\n          <option> A* algorithm</option>\n          <option>Dijkstra</option>\n          <option>Greedy BFS</option>\n          <option>Bidirectional Greedy Search</option>\n          <hr />\n          <option>Depth First Search</option>\n          <option>Breadth First Search</option>\n        </select>\n        </div>\n        <button onClick={visualizer} style={{ backgroundColor : \"#008000\",color : \"white\", borderColor : \"#008000\", padding : 8}}>\n          VISUALIZER\n        </button>\n        <button onClick={clearGrid} style={{ backgroundColor : \"red\",color : \"white\", borderColor : \"red\",padding : 8, width: 200 }}>\n          CLEAR\n        </button>\n        <div className=\"box\">\n        <select onChange={(event) => handleMazeChange(event)} >\n          <option>Random Maze</option>\n          <option>Recursive Maze</option>\n          <option>Vertical Maze</option>\n          <option>Horizontal Maze</option>\n        </select>\n        </div>\n        <button\n          type=\"button\"\n          style={{ backgroundColor : \"#008000\",color : \"white\",borderColor : \"#008000\", padding : 8, width : 200}}\n          onClick={generateMaze}\n        >\n          GENERATE MAZE\n        </button>\n      </div>\n      <div\n        className={\n          visualizingAlgorithm || generatingMaze ? \"grid-visualizing\" : \"grid\"\n        }>\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId}>\n              {row.map((node, nodeId) => {\n                const {\n                  row,\n                  col,\n                  isStart,\n                  isFinish,\n                  isVisited,\n                  isShortest,\n                  isWall,\n                } = node;\n                return (\n                  <Node\n                    key={nodeId}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isVisited={isVisited}\n                    isShortest={isShortest}\n                    isWall={isWall}\n                    width={width}\n                    height={height}\n                    numRows={numRows}\n                    numColumns={numColumns}\n                    onDragOver={(e) => handleDragOver(e)}\n                    onDragStart={(event) => handleDragStart(event, row, col)}\n                    onDrop={() => handleDrop(row, col)}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nfunction getInitialNum(width, height) {\n  let numColumns;\n  if (width > 1500) {\n    numColumns = Math.floor(width / 25);\n  } else if (width > 1250) {\n    numColumns = Math.floor(width / 22.5);\n  } else if (width > 1000) {\n    numColumns = Math.floor(width / 20);\n  } else if (width > 750) {\n    numColumns = Math.floor(width / 17.5);\n  } else if (width > 500) {\n    numColumns = Math.floor(width / 15);\n  } else if (width > 250) {\n    numColumns = Math.floor(width / 12.5);\n  } else if (width > 0) {\n    numColumns = Math.floor(width / 10) - 5;\n  }\n  let cellWidth = Math.floor(width / numColumns);\n  let numRows = Math.floor(height / cellWidth) - 5;\n  return [numRows, numColumns];\n}\n\n\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};\n\nconst getVisitedNodesInOrder = (\n  visitedNodesInOrderStart,\n  visitedNodesInOrderFinish\n) => {\n  let visitedNodesInOrder = [];\n  let n = Math.max(\n    visitedNodesInOrderStart.length,\n    visitedNodesInOrderFinish.length\n  );\n  for (let i = 0; i < n; i++) {\n    if (visitedNodesInOrderStart[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderStart[i]);\n    }\n    if (visitedNodesInOrderFinish[i] !== undefined) {\n      visitedNodesInOrder.push(visitedNodesInOrderFinish[i]);\n    }\n  }\n  return visitedNodesInOrder;\n};\n\nfunction getRandomNums(num) {\n  let randomNums1 = [];\n  let temp = 2;\n  for (let i = 5; i < num / 2; i += 2) {\n    randomNums1.push(temp);\n    temp += 2;\n  }\n  let randomNums2 = [];\n  temp = -2;\n  for (let i = num / 2; i < num - 5; i += 2) {\n    randomNums2.push(temp);\n    temp -= 2;\n  }\n  return [randomNums1, randomNums2];\n}\n\nfunction getStartFinishNode(numRows, numColumns) {\n  let randomNums;\n  let x;\n  let y;\n  let startNodeRow;\n  let startNodeCol;\n  let finishNodeRow;\n  let finishNodeCol;\n  if (numRows < numColumns) {\n    randomNums = getRandomNums(numRows);\n    x = Math.floor(numRows / 2);\n    y = Math.floor(numColumns / 4);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow =\n      x + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    startNodeCol = y + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    finishNodeRow =\n      x + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n    finishNodeCol =\n      numColumns - y + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n  } else {\n    randomNums = getRandomNums(numColumns);\n    x = Math.floor(numRows / 4);\n    y = Math.floor(numColumns / 2);\n    if (x % 2 !== 0) x -= 1;\n    if (y % 2 !== 0) y += 1;\n    startNodeRow = x + [-6, -4, -2, 0][Math.floor(Math.random() * 4)];\n    startNodeCol =\n      y + randomNums[1][Math.floor(Math.random() * randomNums[1].length)];\n    finishNodeRow = numRows - x + [0, 2, 4, 6][Math.floor(Math.random() * 4)];\n    finishNodeCol =\n      y + randomNums[0][Math.floor(Math.random() * randomNums[0].length)];\n  }\n  return [startNodeRow, startNodeCol, finishNodeRow, finishNodeCol];\n}\n\nexport default PathFindingVisualizer;\n","export function randomMaze(grid, startNode, finishNode) {\n    if (!startNode || !finishNode || startNode === finishNode) {\n      return false;\n    }\n    let walls = [];\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[0].length; col++) {\n        if (\n          (row === startNode.row && col === startNode.col) ||\n          (row === finishNode.row && col === finishNode.col)\n        )\n          continue;\n        if (Math.random() < 0.33) {\n          walls.push([row, col]);\n        }\n      }\n    }\n    walls.sort(() => Math.random() - 0.5);\n    return walls;\n  }\n  ","import React from 'react'\nimport PathFindingVisualizer from \"../PathFindingVisualizer/PathFindingVisualizer\"\n\nconst PathFindingVisualizerScreen = () => {\n    return (\n        <>\n            <PathFindingVisualizer />\n        </>\n    )\n}\n\nexport default PathFindingVisualizerScreen\n","import React, { useState, useEffect } from \"react\";\nimport Slider from \"@material-ui/core/Slider\";\nimport Typography from \"@material-ui/core/Typography\";\nimport { makeStyles } from \"@material-ui/core/styles\";\n\nimport \"./SortingVisualizer.css\";\nimport bubbleSortAnimation from \"./SortingAnimations/bubbleSortAnimation\";\nimport quickSortAnimation from \"./SortingAnimations/quickSortAnimation\";\nimport selectionSortAnimation from \"./SortingAnimations/selectionSortAnimation\";\nimport insertionSortAnimation from \"./SortingAnimations/insertionSortAnimation\";\nimport mergeSortAnimation from \"./SortingAnimations/mergeSortAnimation\";\nimport BubbleSortComponent from \"./components/bubbleSortComponent\";\nimport MergeSortComponent from \"./components/mergeSortComponent\";\n\nconst useStyles = makeStyles({\n  root: {\n    width: 165,\n    position : \"relative\",\n    bottom : 8,\n  },\n  label:{\n    fontSize : 13,\n    position : \"relative\",\n    top : 2,\n    color : \"white\",\n    fontWeight : \"bold\"\n  }\n});\nconst PRIMARY_COLOR = \"turquoise\";\nconst SortingVisualizer = () => {\n  const classes = useStyles();\n  const [array, setArray] = useState([]);\n  const [value, setValue] = useState(30);\n  const [ANIMATION_SPEED_MS, setANIMATION_SPEED_MS] = useState(2);\n  const [currentSort, setCurrentSort] = useState(\"Algorithms\");\n  const [visualizing,setVisualizig] = useState();\n\n  //Run this during first render\n  useEffect(() => {\n    const { _height } = getWindowDimensions();\n\n    const _resetArray = () => {\n      const temp = [];\n    for (let i = 0; i < value; i++) {\n      temp.push(randomIntFromInterval(5, _height - _height / 3.5));\n    }\n    setArray(temp);\n    const allBars = document.querySelectorAll(\".arraybar\");\n    for (let i = 0; i < allBars.length; i++) {\n      const barStyle = allBars[i].style;\n      barStyle.backgroundColor = \"turquoise\";\n    };\n  }\n    _resetArray();\n  }, []);\n\n  //Getting dimensions of window\n  function getWindowDimensions() {\n    const { innerWidth: _width, innerHeight: _height } = window;\n    return {\n      _width,\n      _height,\n    };\n  }\n\n  //Calling getWindowDimensions method(destructering)\n  const { _height, _width } = getWindowDimensions();\n  const newWidth = _width - _width / 8;\n\n  //creating new random array\n  const resetArray = (NO_OF_ARRAY_BAR) => {\n    \n      clearTimeout(visualizing)\n    \n    const temp = [];\n    for (let i = 0; i < NO_OF_ARRAY_BAR; i++) {\n      temp.push(randomIntFromInterval(5, _height - _height / 4));\n    }\n    setArray(temp);\n    const allBars = document.querySelectorAll(\".arraybar\");\n    for (let i = 0; i < allBars.length; i++) {\n      const barStyle = allBars[i].style;\n      barStyle.backgroundColor = \"turquoise\";\n    }\n  };\n\n  //Creating random Integer\n  const randomIntFromInterval = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  };\n\n  //BubbleSort animation\n  const _bubbleSort = () => {\n    bubbleSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n\n  //MergeSort Animation\n  const _mergeSort = () => {\n    mergeSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n\n  //QuickSort Animation\n  const _quickSort = () => {\n    quickSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n\n  const _selectionSort = () => {\n\n    selectionSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n  const _insertionSort = () => {\n    insertionSortAnimation(array, ANIMATION_SPEED_MS);\n  };\n  const handleChange = (event, value) => {\n    setValue(value);\n    resetArray(value);\n  };\n  const handleChangeSpeed = (event, value) => {\n    setANIMATION_SPEED_MS(event.target.value);\n  };\n  const handleChangeCurrentSort = (event) => {\n    setCurrentSort(event.target.value);\n  };\n  const visualizeAlgorithm = () => {\n    switch (currentSort) {\n      case \"bubbleSort\":\n       const bubble = _bubbleSort();\n       setVisualizig(bubble)\n        break;\n      case \"insertionSort\":\n       const insert = _insertionSort();\n       setVisualizig(insert);\n        break;\n      case \"quickSort\":\n        const quick = _quickSort();\n        break;\n      case \"mergeSort\":\n       const merge = _mergeSort();\n       setVisualizig(merge)\n        break;\n      case \"selectionSort\":\n       const select = _selectionSort();\n       setVisualizig(select)\n        break;\n      default:\n        _bubbleSort();\n        break;\n    }\n  };\n\n  return (\n    <div className=\"array-container\">\n      <div className=\"infoBar-container\">\n        <div style={{ paddingTop : 10}}>\n          <div className=\"box\" style={{ display : \"inline\",position: \"relative\", bottom : 10}}>\n          <select onChange={handleChangeSpeed}>\n            <option value=\"2\">TOO FAST</option>\n            <option value=\"20\">FAST</option>\n            <option value=\"100\">SLOW</option>\n            <option value=\"2000\">TOO SLOW</option>\n          </select>\n          </div>\n        </div>\n        <div className=\"slider-container\">\n        {/* <Typography className={classes.label} gutterBottom>\n              SPEED\n          </Typography>          \n          <Slider\n            className={classes.root}\n            value={ANIMATION_SPEED_MS}\n            min={2}\n            max={230}\n            onChange={handleChangeSpeed}\n            aria-labelledby=\"continuous-slider\"\n          /> */}\n\n          <Typography className={classes.label}>\n            BARS\n          </Typography>\n          <Slider\n            className={classes.root}\n            value={value}\n            min={10}\n            max={newWidth / 5 - 20}\n            onChange={handleChange}\n            aria-labelledby=\"continuous-slider\"\n          />\n        </div>\n        <div className=\"button-container\">\n          {/* Button 3 */}\n          <button  style={{backgroundColor : \"#228b22\", color : \"whitesmoke\", borderColor : \"#228b22\",width : 150}} onClick={() => resetArray(value)}>Generate new Array</button>\n            <div className=\"box\" style={{ display : \"inline\",position: \"relative\", bottom : 10}}>\n          <select onChange={handleChangeCurrentSort} >\n            <option selected value=\"bubbleSort\">\n              Bubble Sort\n            </option>\n            <option value=\"insertionSort\">Insertion Sort</option>\n            <option value=\"quickSort\">Quick Sort</option>\n            <option value=\"mergeSort\">Merge Sort</option>\n            <option value=\"selectionSort\">SelectionSort</option>\n          </select>\n          </div>\n          <button  style={{backgroundColor : \"#228b22\", color : \"whitesmoke\", borderColor : \"#228b22\",width : 150}} onClick={visualizeAlgorithm}>Visuaize Algorithm</button>\n        </div>\n        <div className=\"grap-container\">{/* Graph or Index */}\n        <div>\n        <BubbleSortComponent />\n        </div>\n       \n        </div>\n        <div className=\"temp\">\n        <MergeSortComponent />\n        </div>\n      </div>\n\n      {/* Array Bars */}\n      <div className=\"arraybar-container\">\n        {array.map((_value, index) => (\n          <div\n            className=\"arraybar\"\n            key={index}\n            style={{\n              height: `${_value}px`,\n              width: newWidth / value - 2,\n              paddingLeft: 0,\n              backgroundColor: PRIMARY_COLOR,\n            }}\n          ></div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default SortingVisualizer;\n","import \"./App.css\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport PathFindingVisualizerScreen from \"./Screens/PathFindingVisualizerScreen\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\nimport NavBar from \"./navbar/navbar.jsx\";\n\nfunction App() {\n  return (\n    // <Router>\n    //   <NavBar />\n    //   <Switch>\n    //   <Route exact path=\"/\" component={SortingVisualizer} />\n    //     <Route exact path=\"/pathFinding\" component={PathFindingVisualizerScreen} />\n    //   </Switch>\n    // </Router>\n    <Router>\n      <PathFindingVisualizerScreen />\n    </Router>\n\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n// import { HashRouter } from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}